trash <- data$remDr$executeScript(script, args = list(ProbDATA1,
AssessDATA1,
PlanDATA1,
ProbDATA2,
paste(VitalDATA,"\n",AssessDATA2,sep=""),
PlanDATA2,
WeeklySumTXT,
WeeklyDiagnosis))[[1]]
#save
#unknown bug that results in freezing sometimes....
doTillSuccess({
webElem7 <- data$remDr$findElement(using = "id", value = "NTUHWeb1_WeeklySummaryMainTab_btnSaveWeeklySummary")
webElem7$clickElement()
},data)
#wait till complete
wait_till_textappear(data, "NTUHWeb1_WeeklySummaryMainTab_lblShowMessage", "暫存成功",
15,{
data$remDr$navigate(PNlink)
data$remDr$refresh()
source("OpenNewAddWeeklyNote.R")
#wait
wait_till_IDloaded(data,"NTUHWeb1_WeeklySummaryMainTab_ucPAP_txbProblem1")
wait_till_IDloaded(data,"NTUHWeb1_WeeklySummaryMainTab_ucPAP_txbProblem2")
#Write content
script <- 'document.getElementById("NTUHWeb1_WeeklySummaryMainTab_ucPAP_txbProblem1").value = arguments[0];
document.getElementById("NTUHWeb1_WeeklySummaryMainTab_ucPAP_txbAssessment1").value = arguments[1];
document.getElementById("NTUHWeb1_WeeklySummaryMainTab_ucPAP_txbPlan1").value = arguments[2];
document.getElementById("NTUHWeb1_WeeklySummaryMainTab_ucPAP_txbProblem2").value = arguments[3];
document.getElementById("NTUHWeb1_WeeklySummaryMainTab_ucPAP_txbAssessment2").value = arguments[4];
document.getElementById("NTUHWeb1_WeeklySummaryMainTab_ucPAP_txbPlan2").value = arguments[5];
document.getElementById("NTUHWeb1_WeeklySummaryMainTab_txbBriefSummary").value = arguments[6];
document.getElementById("NTUHWeb1_WeeklySummaryMainTab_txbDiagnosis").value = arguments[7];'
trash <- data$remDr$executeScript(script, args = list(ProbDATA1,
AssessDATA1,
PlanDATA1,
ProbDATA2,
paste(VitalDATA,"\n",AssessDATA2,sep=""),
PlanDATA2,
WeeklySumTXT,
WeeklyDiagnosis))[[1]]
##
Sys.sleep(3)
##
webElem7 <- data$remDr$findElement(using = "id", value = "NTUHWeb1_WeeklySummaryMainTab_btnSaveWeeklySummary")
webElem7$clickElement()
})
#wait_till_ClassLoaded(data,"blockUI blockMsg blockPage")
#wait_till_ClassLoaded(data,"growlUI")
#wait_till_ClassDisappear(data,"growlUI")
##########################################
## add two free notes as progress notes ##
##########################################
for (PN.index in 1:as.numeric(PNnoteNum)){ #notes number determined by user - PNnoteNum
#for (PN.index in 1:4){ #four notes
#refresh
#Sys.sleep(1)
data$remDr$refresh()
data$remDr$navigate(PNlink)
wait_till_element(data$remDr, "NTUHWeb1_ProblemQueryByAccList1_btnDisplayInValidProblem")
#click add new progress note
Sys.sleep(1)
clickElement(data,"NTUHWeb1_btnInsertBlankNote")
Sys.sleep(1)
wait_till_steadystate(data,"/html/body", steadythres = 5)
#wait_till_IDloaded(data,"Layer1")
#
rootNode<-reloadHTML(data)
NoteList<-xpathSApply(rootNode,
'//*[@id="tblNoteList"]/tbody/tr/td[@class="helpBod helpTimeField pointerCursor"]',
xmlGetAttr, name = "title")
while (T){
if (length(NoteList)!=0){
newProgNote <- (grepl("請輸入標題", tolower(NoteList)) & grepl("暫存", tolower(NoteList)) &
(difftime(Sys.Date(),as.Date(sapply(NoteList,str_extract,"\\d\\d\\d\\d/\\d\\d?/\\d\\d?")),units = "days") == 0))  #bug for future notes
#to do the new added, must >0
if (sum(newProgNote)!=0) #if any is true
{ break } #break if complete - where there is "請輸入標題", "暫存" at today's date
}#end if
#
#Sys.sleep(2)
#
data$remDr$refresh()
wait_till_steadystate(data,"/html/body", steadythres = 5) #wait
##reload the page
data$remDr$navigate(PNlink)
wait_till_element(data$remDr, "NTUHWeb1_ProblemQueryByAccList1_btnDisplayInValidProblem")
#
rootNode<-reloadHTML(data)
NoteList<-xpathSApply(rootNode,
'//*[@id="tblNoteList"]/tbody/tr/td[@class="helpBod helpTimeField pointerCursor"]',
xmlGetAttr, name = "title")
}#end while
##Open newly added weeklyPN, write content and click save
source("open_writeNewWeekPN.R")
#wait till complete
wait_till_textappear(data,
"NTUHWeb1_BlankNoteMainTab_lblShowMessage",
"暫存成功",
15, {
#webElem9 <- data$remDr$findElement(using = "id", value = "NTUHWeb1_BlankNoteMainTab_btnSaveBlankNote")
#webElem9$clickElement()
data$remDr$refresh()
data$remDr$navigate(PNlink)
source("open_writeNewWeekPN.R")
})
#wait_till_ClassLoaded(data,"growlUI")
#wait_till_ClassDisappear(data,"growlUI")
}#end for how much PNs
##
}#end if ignore MBD within 24 hrs
}#end for
setwd("/Users/peishenwu/Google 雲端硬碟/【01】醫學/PMR/R2/排班/Planner")  ##modify the path here...
options(stringsAsFactors = FALSE)
set.seed(1234)
library(utils)
##
##worker functions
mininterval <- function(x){
result = Inf
if (length(x) >1){
#result = min(sapply(2:length(x),function(i){x[i]-x[i-1]}))
result = min(x[2:length(x)] - x[1:length(x)-1]) #vectorized version
}
result
}#end function
##
data <- readRDS("swapper_output.rds")
names(data)
View(data$quality)
View(data$results[[1]])
results <- data$results
persondata <- data$persondata
contraspace <- data$contraspace
holidays <- data$holidays
contraspace_days <- data$  contraspace_days
quality <- data.frame(resultIndex = 1:length(results),
cQODs = rep(NA,length(results)),
discrete = rep(NA,length(results)),
cSenior = rep(NA,length(results)),
continQODs = rep(NA,length(results)),
NoContras = rep(NA, length(results)),
NotFollowHoliday = rep(NA, length(results)),
NotFollowWorkday = rep(NA, length(results)),
OnlyTwoDutiesPerDay = rep(NA, length(results)),
FollowAllAppointments = rep(NA, length(results)))
pb <- txtProgressBar(min = 1, max = length(results), style=3)
message("\nCalculating quality...")
for (item in 1:length(results)){
progress(item)
#
quality$cSenior[item] <- sum(apply(results[[item]][senior_rowindex,],2,sum) == 2)
quality$discrete[item] <- min(apply(results[[item]],1,
function(x){
mean(getintervals(c(1:ncol(results[[item]]))[x == 1]))
}))
quality$cQODs[item] <- sum(apply(results[[item]],1,
function(x){
sum(getintervals(c(1:ncol(results[[item]]))[x == 1]) == 2)
}))
quality$continQODs[item] <- sum(apply(results[[item]],1,
function(x){
repeatdetect(getintervals(c(1:ncol(results[[item]]))[x == 1]),2)
}))
quality$NoContras[item] <- (sum((contraspace + results[[item]]) == 2) == 0)
quality$NotFollowHoliday[item] <- sum(apply(results[[item]][,c(holidays)],1,sum) != strucdata$holidays)
quality$NotFollowWorkday[item] <- sum(apply(results[[item]][,-c(holidays)],1,sum) != strucdata$workdays)
quality$OnlyTwoDutiesPerDay[item] <- sum(apply(results[[item]],2,sum) != 2)
quality$FollowAllAppointments[item] <- sum((results[[item]] & appointspace) != appointspace) == 0
}#end for
pb <- txtProgressBar(min = 1, max = length(results), style=3)
progress <- function(n){ setTxtProgressBar(pb, n) }
opts <- list(progress=progress)
quality <- data.frame(resultIndex = 1:length(results),
cQODs = rep(NA,length(results)),
discrete = rep(NA,length(results)),
cSenior = rep(NA,length(results)),
continQODs = rep(NA,length(results)),
NoContras = rep(NA, length(results)),
NotFollowHoliday = rep(NA, length(results)),
NotFollowWorkday = rep(NA, length(results)),
OnlyTwoDutiesPerDay = rep(NA, length(results)),
FollowAllAppointments = rep(NA, length(results)))
pb <- txtProgressBar(min = 1, max = length(results), style=3)
message("\nCalculating quality...")
for (item in 1:length(results)){
progress(item)
#
quality$cSenior[item] <- sum(apply(results[[item]][senior_rowindex,],2,sum) == 2)
quality$discrete[item] <- min(apply(results[[item]],1,
function(x){
mean(getintervals(c(1:ncol(results[[item]]))[x == 1]))
}))
quality$cQODs[item] <- sum(apply(results[[item]],1,
function(x){
sum(getintervals(c(1:ncol(results[[item]]))[x == 1]) == 2)
}))
quality$continQODs[item] <- sum(apply(results[[item]],1,
function(x){
repeatdetect(getintervals(c(1:ncol(results[[item]]))[x == 1]),2)
}))
quality$NoContras[item] <- (sum((contraspace + results[[item]]) == 2) == 0)
quality$NotFollowHoliday[item] <- sum(apply(results[[item]][,c(holidays)],1,sum) != strucdata$holidays)
quality$NotFollowWorkday[item] <- sum(apply(results[[item]][,-c(holidays)],1,sum) != strucdata$workdays)
quality$OnlyTwoDutiesPerDay[item] <- sum(apply(results[[item]],2,sum) != 2)
quality$FollowAllAppointments[item] <- sum((results[[item]] & appointspace) != appointspace) == 0
}#end for
junior_rowindex <- c(1:length(persondata$level))[persondata$level %in% c("R1","R2")]
senior_rowindex <- c(1:length(persondata$level))[persondata$level %in% c("R3","R4")]
quality <- data.frame(resultIndex = 1:length(results),
cQODs = rep(NA,length(results)),
discrete = rep(NA,length(results)),
cSenior = rep(NA,length(results)),
continQODs = rep(NA,length(results)),
NoContras = rep(NA, length(results)),
NotFollowHoliday = rep(NA, length(results)),
NotFollowWorkday = rep(NA, length(results)),
OnlyTwoDutiesPerDay = rep(NA, length(results)),
FollowAllAppointments = rep(NA, length(results)))
pb <- txtProgressBar(min = 1, max = length(results), style=3)
message("\nCalculating quality...")
for (item in 1:length(results)){
progress(item)
#
quality$cSenior[item] <- sum(apply(results[[item]][senior_rowindex,],2,sum) == 2)
quality$discrete[item] <- min(apply(results[[item]],1,
function(x){
mean(getintervals(c(1:ncol(results[[item]]))[x == 1]))
}))
quality$cQODs[item] <- sum(apply(results[[item]],1,
function(x){
sum(getintervals(c(1:ncol(results[[item]]))[x == 1]) == 2)
}))
quality$continQODs[item] <- sum(apply(results[[item]],1,
function(x){
repeatdetect(getintervals(c(1:ncol(results[[item]]))[x == 1]),2)
}))
quality$NoContras[item] <- (sum((contraspace + results[[item]]) == 2) == 0)
quality$NotFollowHoliday[item] <- sum(apply(results[[item]][,c(holidays)],1,sum) != strucdata$holidays)
quality$NotFollowWorkday[item] <- sum(apply(results[[item]][,-c(holidays)],1,sum) != strucdata$workdays)
quality$OnlyTwoDutiesPerDay[item] <- sum(apply(results[[item]],2,sum) != 2)
quality$FollowAllAppointments[item] <- sum((results[[item]] & appointspace) != appointspace) == 0
}#end for
mininterval <- function(x){
result = Inf
if (length(x) >1){
#result = min(sapply(2:length(x),function(i){x[i]-x[i-1]}))
result = min(x[2:length(x)] - x[1:length(x)-1]) #vectorized version
}
result
}#end function
getintervals <- function(x){
result = Inf
if (length(x) >1){
result = (sapply(2:length(x),function(i){x[i]-x[i-1]}))
}
result
}#end function
repeatdetect <- function(x, target){
result = 0
if (length(x)>1){
result <- sum(sapply(2:length(x),
function(i){
(x[i] == x[i-1]) * (x[i] == target)
}))
}
result
}#end function
#
quality <- data.frame(resultIndex = 1:length(results),
cQODs = rep(NA,length(results)),
discrete = rep(NA,length(results)),
cSenior = rep(NA,length(results)),
continQODs = rep(NA,length(results)),
NoContras = rep(NA, length(results)),
NotFollowHoliday = rep(NA, length(results)),
NotFollowWorkday = rep(NA, length(results)),
OnlyTwoDutiesPerDay = rep(NA, length(results)),
FollowAllAppointments = rep(NA, length(results)))
pb <- txtProgressBar(min = 1, max = length(results), style=3)
message("\nCalculating quality...")
for (item in 1:length(results)){
progress(item)
#
quality$cSenior[item] <- sum(apply(results[[item]][senior_rowindex,],2,sum) == 2)
quality$discrete[item] <- min(apply(results[[item]],1,
function(x){
mean(getintervals(c(1:ncol(results[[item]]))[x == 1]))
}))
quality$cQODs[item] <- sum(apply(results[[item]],1,
function(x){
sum(getintervals(c(1:ncol(results[[item]]))[x == 1]) == 2)
}))
quality$continQODs[item] <- sum(apply(results[[item]],1,
function(x){
repeatdetect(getintervals(c(1:ncol(results[[item]]))[x == 1]),2)
}))
quality$NoContras[item] <- (sum((contraspace + results[[item]]) == 2) == 0)
quality$NotFollowHoliday[item] <- sum(apply(results[[item]][,c(holidays)],1,sum) != strucdata$holidays)
quality$NotFollowWorkday[item] <- sum(apply(results[[item]][,-c(holidays)],1,sum) != strucdata$workdays)
quality$OnlyTwoDutiesPerDay[item] <- sum(apply(results[[item]],2,sum) != 2)
quality$FollowAllAppointments[item] <- sum((results[[item]] & appointspace) != appointspace) == 0
}#end for
strucdata <- data$strucdata
quality <- data.frame(resultIndex = 1:length(results),
cQODs = rep(NA,length(results)),
discrete = rep(NA,length(results)),
cSenior = rep(NA,length(results)),
continQODs = rep(NA,length(results)),
NoContras = rep(NA, length(results)),
NotFollowHoliday = rep(NA, length(results)),
NotFollowWorkday = rep(NA, length(results)),
OnlyTwoDutiesPerDay = rep(NA, length(results)),
FollowAllAppointments = rep(NA, length(results)))
pb <- txtProgressBar(min = 1, max = length(results), style=3)
message("\nCalculating quality...")
for (item in 1:length(results)){
progress(item)
#
quality$cSenior[item] <- sum(apply(results[[item]][senior_rowindex,],2,sum) == 2)
quality$discrete[item] <- min(apply(results[[item]],1,
function(x){
mean(getintervals(c(1:ncol(results[[item]]))[x == 1]))
}))
quality$cQODs[item] <- sum(apply(results[[item]],1,
function(x){
sum(getintervals(c(1:ncol(results[[item]]))[x == 1]) == 2)
}))
quality$continQODs[item] <- sum(apply(results[[item]],1,
function(x){
repeatdetect(getintervals(c(1:ncol(results[[item]]))[x == 1]),2)
}))
quality$NoContras[item] <- (sum((contraspace + results[[item]]) == 2) == 0)
quality$NotFollowHoliday[item] <- sum(apply(results[[item]][,c(holidays)],1,sum) != strucdata$holidays)
quality$NotFollowWorkday[item] <- sum(apply(results[[item]][,-c(holidays)],1,sum) != strucdata$workdays)
quality$OnlyTwoDutiesPerDay[item] <- sum(apply(results[[item]],2,sum) != 2)
quality$FollowAllAppointments[item] <- sum((results[[item]] & appointspace) != appointspace) == 0
}#end for
data <- readRDS("planner_output.rds")
appointspace <- data$appointspace
quality <- data.frame(resultIndex = 1:length(results),
cQODs = rep(NA,length(results)),
discrete = rep(NA,length(results)),
cSenior = rep(NA,length(results)),
continQODs = rep(NA,length(results)),
NoContras = rep(NA, length(results)),
NotFollowHoliday = rep(NA, length(results)),
NotFollowWorkday = rep(NA, length(results)),
OnlyTwoDutiesPerDay = rep(NA, length(results)),
FollowAllAppointments = rep(NA, length(results)))
pb <- txtProgressBar(min = 1, max = length(results), style=3)
message("\nCalculating quality...")
for (item in 1:length(results)){
progress(item)
#
quality$cSenior[item] <- sum(apply(results[[item]][senior_rowindex,],2,sum) == 2)
quality$discrete[item] <- min(apply(results[[item]],1,
function(x){
mean(getintervals(c(1:ncol(results[[item]]))[x == 1]))
}))
quality$cQODs[item] <- sum(apply(results[[item]],1,
function(x){
sum(getintervals(c(1:ncol(results[[item]]))[x == 1]) == 2)
}))
quality$continQODs[item] <- sum(apply(results[[item]],1,
function(x){
repeatdetect(getintervals(c(1:ncol(results[[item]]))[x == 1]),2)
}))
quality$NoContras[item] <- (sum((contraspace + results[[item]]) == 2) == 0)
quality$NotFollowHoliday[item] <- sum(apply(results[[item]][,c(holidays)],1,sum) != strucdata$holidays)
quality$NotFollowWorkday[item] <- sum(apply(results[[item]][,-c(holidays)],1,sum) != strucdata$workdays)
quality$OnlyTwoDutiesPerDay[item] <- sum(apply(results[[item]],2,sum) != 2)
quality$FollowAllAppointments[item] <- sum((results[[item]] & appointspace) != appointspace) == 0
}#end for
View(quality)
quality[quality$NoContras == T &
quality$NotFollowHoliday == 0 &
quality$NotFollowWorkday == 0 &
quality$OnlyTwoDutiesPerDay == 0 &
quality$continQODs == 0 &
quality$cSenior == 0 &
quality$FollowAllAppointments == T,]
View(quality)
quality$FollowAllAppointments == T
quality[quality$NoContras == T &
quality$NotFollowHoliday == 0 &
quality$NotFollowWorkday == 0 &
quality$OnlyTwoDutiesPerDay == 0 &
quality$continQODs == 0 &
# quality$cSenior == 0 &
quality$FollowAllAppointments == T,]
item=1
apply(results[[item]][,-c(holidays)],1,sum)
strucdata$workdays
apply(results[[item]][,-c(holidays)],1,sum) != strucdata$workdays
View(persondata)
options(stringsAsFactors = FALSE,
scipen=999) ##disable scientific number notation
set.seed(1234)
library(xlsx)
#library(utils)
library(compiler)
#
##do Iterations
iter_max = 300000
#
config.data <- read.xlsx("planner_config.xlsx", 1, row.names = NULL)
contraspace <- config.data[2:nrow(config.data),-c(1,2,ncol(config.data), (ncol(config.data)-1))]
persondata <- config.data[2:nrow(config.data),c(1,2)]
Encoding(persondata$name) <- "UTF-8"
strucdata <- config.data[2:nrow(config.data),c(ncol(config.data), (ncol(config.data)-1))]
holidays <- config.data[1,-c(1,2,ncol(config.data), (ncol(config.data)-1))]
holidays <- as.numeric(gsub("X","",names(holidays[,holidays == 1])))
contraspace_days <- as.numeric(gsub("X","",names(contraspace)))
junior_rowindex <- c(1:length(persondata$level))[persondata$level %in% c("R1","R2")]
senior_rowindex <- c(1:length(persondata$level))[persondata$level %in% c("R3","R4")]
##sort by complexity
sort.config.data <- data.frame(persondata, strucdata,
flexible_holidays = rep(Inf,nrow(contraspace)),
flexible_workdays = rep(Inf,nrow(contraspace)),
contraspace)
for(irow in 1:nrow(contraspace)){
availabledays <- contraspace[irow,]
availabledays <- contraspace_days[availabledays == 0]
available.holidays <- availabledays[(availabledays %in% holidays)]
available.workdays <- availabledays[!(availabledays %in% holidays)]
#
sort.config.data$flexible_holidays[irow] <- length(available.holidays) - strucdata$holidays[irow]
sort.config.data$flexible_workdays[irow] <- length(available.workdays) - strucdata$workdays[irow]
}#end for
sort.config.data <- sort.config.data[order(sort.config.data$flexible_holidays,
sort.config.data$flexible_workdays,
decreasing = F),]
contraspace <- sort.config.data[,-c(1:6)]
appointspace <- 1*(contraspace == 2)
contraspace <- contraspace - 2*appointspace
##
strucdata <- sort.config.data[, c(3,4)]
persondata <- sort.config.data[, c(1,2)]
## check for configuration error
if ((sum(sort.config.data$flexible_holidays < 0) + sum(sort.config.data$flexible_workdays < 0)) != 0){
stop("Error !! Someone set too much contras, leading to not enough available workdays or holidays")
}#end if
count_holidays <- length(holidays)
count_workdays <- length(contraspace_days) - count_holidays
if (sum(strucdata$workdays) != 2*count_workdays | sum(strucdata$holidays) != 2*count_holidays){
stop("Error in holidays or workdays configuration")
}#end if
## if more than two persons appoint the same day for on-duty, then it's an error
if (sum(apply(contraspace, 2, function(x){sum(x == 2)}) > 2) != 0){
stop("Error !! more than two persons appoint the same day for on-duty")
}#end if
## update strucdata according to appointing specific days for on-duty
## this is done AFTER the configuration checks... but BEFORE algorithm begins
appoint_holidays <- apply(appointspace[,holidays],1,sum)
appoint_workdays <- apply(appointspace[,-holidays],1,sum)
strucdata$holidays <- strucdata$holidays - appoint_holidays
strucdata$workdays <- strucdata$workdays - appoint_workdays
##worker functions
getintervals <- function(x){
result = Inf
if (length(x) >1){
result = (sapply(2:length(x),function(i){x[i]-x[i-1]}))
}
result
}#end function
repeatdetect <- function(x, target){
result = 0
if (length(x)>1){
result <- sum(sapply(2:length(x),
function(i){
(x[i] == x[i-1]) * (x[i] == target)
}))
}
result
}#end function
#pb <- txtProgressBar(min = 1, max = iter_max, style=3)
#progress <- function(n){ setTxtProgressBar(pb, n) }
appoint_holidays
appoint_workdays
appoint_struc <- data.frame(workdays = appoint_workdays,
holidays = appoint_holidays)
View(appoint_struc)
count_iter = 0
results <- list()
iter_log <- rep(0,iter_max %/% 250)
##worker functions
mininterval <- function(x){
result = Inf
if (length(x) >1){
#result = min(sapply(2:length(x),function(i){x[i]-x[i-1]}))
result = min(x[2:length(x)] - x[1:length(x)-1]) #vectorized version
}
result
}#end function
##
init_time = Sys.time() #set time at beginning
##
workspace <- appointspace ##initialize with appointment space
contraspace.updated <- (contraspace | appointspace)*1
##update contraspace if 2 duties exist per day (do this first, because it can be filled by appointment)
contraspace.updated[,(apply(workspace,2,sum) == 2)] <- 1
irow=1
availabledays <- contraspace.updated[irow,]
availabledays <- contraspace_days[availabledays != 1]
##reset
holiday.to.fill <- NULL
workday.to.fill <- NULL
View(appoint_struc)
- appoint_struc$holidays[irow]
appoint_struc$workdays[irow]
strucdata$workdays[irow] - appoint_struc$workdays[irow]
strucdata$workdays[irow]
