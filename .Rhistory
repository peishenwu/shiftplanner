ProbDATA2,
paste(VitalDATA,"\n",AssessDATA2,sep=""),
PlanDATA2,
WeeklySumTXT,
WeeklyDiagnosis))[[1]]
##
webElem7 <- data$remDr$findElement(using = "id", value = "NTUHWeb1_WeeklySummaryMainTab_btnSaveWeeklySummary")
webElem7$clickElement()
})
#wait_till_ClassLoaded(data,"blockUI blockMsg blockPage")
#wait_till_ClassLoaded(data,"growlUI")
#wait_till_ClassDisappear(data,"growlUI")
##########################################
## add two free notes as progress notes ##
##########################################
for (PN.index in 1:as.numeric(PNnoteNum)){ #notes number determined by user - PNnoteNum
#for (PN.index in 1:4){ #four notes
#refresh
#Sys.sleep(1)
data$remDr$refresh()
data$remDr$navigate(PNlink)
wait_till_element(data$remDr, "NTUHWeb1_ProblemQueryByAccList1_btnDisplayInValidProblem")
#click add new progress note
Sys.sleep(1)
clickElement(data,"NTUHWeb1_btnInsertBlankNote")
Sys.sleep(1)
wait_till_steadystate(data,"/html/body", steadythres = 5)
#wait_till_IDloaded(data,"Layer1")
#
rootNode<-reloadHTML(data)
NoteList<-xpathSApply(rootNode,
'//*[@id="tblNoteList"]/tbody/tr/td[@class="helpBod helpTimeField pointerCursor"]',
xmlGetAttr, name = "title")
while (T){
if (length(NoteList)!=0){
newProgNote <- (grepl("請輸入標題", tolower(NoteList)) & grepl("暫存", tolower(NoteList)) &
(difftime(Sys.Date(),as.Date(sapply(NoteList,str_extract,"\\d\\d\\d\\d/\\d\\d?/\\d\\d?")),units = "days") == 0))  #bug for future notes
#to do the new added, must >0
if (sum(newProgNote)!=0) #if any is true
{ break } #break if complete - where there is "請輸入標題", "暫存" at today's date
}#end if
#
#Sys.sleep(2)
#
data$remDr$refresh()
wait_till_steadystate(data,"/html/body", steadythres = 5) #wait
##reload the page
data$remDr$navigate(PNlink)
wait_till_element(data$remDr, "NTUHWeb1_ProblemQueryByAccList1_btnDisplayInValidProblem")
#
rootNode<-reloadHTML(data)
NoteList<-xpathSApply(rootNode,
'//*[@id="tblNoteList"]/tbody/tr/td[@class="helpBod helpTimeField pointerCursor"]',
xmlGetAttr, name = "title")
}#end while
##Open newly added weeklyPN, write content and click save
source("open_writeNewWeekPN.R")
#wait till complete
wait_till_textappear(data,
"NTUHWeb1_BlankNoteMainTab_lblShowMessage",
"暫存成功",
15, {
#webElem9 <- data$remDr$findElement(using = "id", value = "NTUHWeb1_BlankNoteMainTab_btnSaveBlankNote")
#webElem9$clickElement()
data$remDr$navigate(PNlink)
source("open_writeNewWeekPN.R")
})
#wait_till_ClassLoaded(data,"growlUI")
#wait_till_ClassDisappear(data,"growlUI")
}#end for how much PNs
##
}#end if ignore MBD within 24 hrs
}#end for
##module do weekly note for modification
## does weekly note x1 + progress notes x2
##utilizes the reuslts from crawler.R
#version 2015/12/4
setwd("/Users/peishenwu/Google 雲端硬碟/【01】醫學/PMR/R_portal/R_portal_Sys_v1.0/")
source("CommonLib.R")
source("GetUpdates.R")
#
DutyVS <- EnterBox("Enter duty VS ID:")
PNnoteNum <- EnterBox(" How many days of notes?")
#DutyVS <- c("000908","000908","000908","004554")
#
patientDB <- readRDS("patient_status_DB.rds")
print(paste("patientDB captured at time:",patientDB$captureTime,sep=" ")) #show DB time
patientCount <- length(patientDB$table$name)
#prepare browser
logindata<-portal_login(c(readRDS("defaultUser.rds")))
#print patient list
#patientDB$table[,1:7]
#
#  i= 1
#
for (i in 1:patientCount){
#for (i in c(6)){
#for (i in c(1)){
##print progress
print(paste("Currently working on patient: ",
patientDB$table$ward[i],"-",patientDB$table$room[i],"-",patientDB$table$bed[i]," ",
patientDB$table$name[i]," (",i,"/",patientCount,")",
sep=""))
#ignore those who are MBD today (choose those who's dischargeDate is Inf) ##bug on 2015/4/24
if (dateDiff(patientDB$table$dischargeStatus[i],"%Y/%m/%d") >1){
doTillSuccess({
#navigate to patient by chartNo
navigatePatient(logindata, patientDB$table$chartNo[i])
#wait and get info
wait_till_element(logindata$remDr, "NTUHWeb1_QueryInPatientPersonAccountControl1_DataGridAccountList")
##
data <-  getWardList(logindata$remDr)
},data)
#navigate to progress note
#the one within the same admission date
PNlink <- data$pList[as.character(data$pList$NTUHadmission) == as.character(patientDB$table$NTUHadmission[i]),]$ProgNote
data$remDr$navigate(PNlink)
#wait till loaded
wait_till_element(data$remDr, "NTUHWeb1_ProblemQueryByAccList1_btnDisplayInValidProblem",
retry_thres = 20,
expr = {
data$remDr$navigate(PNlink)
})
#click add new weekly note
clickElement(data,"NTUHWeb1_btnInsertWeeklySummaryNote")
wait_till_steadystate(data,"/html/body", steadythres = 5)
#
rootNode<-reloadHTML(data)
NoteList<-xpathSApply(rootNode,
'//*[@id="tblNoteList"]/tbody/tr/td[@class="helpBod helpTimeField pointerCursor"]',
xmlGetAttr, name = "title")
while (T){
#
if (length(NoteList)!=0){
newProgNote <- (grepl("weekly", tolower(NoteList)) & grepl("暫存", tolower(NoteList)) &
(difftime(Sys.Date(),as.Date(sapply(NoteList,str_extract,"\\d\\d\\d\\d/\\d\\d?/\\d\\d?")),units = "days") == 0))  #bug for future notes
#to do the new added, must >0
if (sum(newProgNote)!=0) #if any is true
{ break } #break if complete - where there is "progress", "暫存" at today's date
}#end if
#
Sys.sleep(1)
data$remDr$refresh()
wait_till_steadystate(data,"/html/body", steadythres = 5) #wait
#
rootNode<-reloadHTML(data)
NoteList<-xpathSApply(rootNode,
'//*[@id="tblNoteList"]/tbody/tr/td[@class="helpBod helpTimeField pointerCursor"]',
xmlGetAttr, name = "title")
}#end while
#determine the index of the newly added note - not always 0
newNoteIndex <- (c(1:length(newProgNote))[newProgNote]-1)[1] #in case of multiple indicies, use the first one
#open newly added note for edit
source("OpenNewAddWeeklyNote.R")
#insert two PAPs
script <- "InsertPAPTab('Weekly');InsertPAPTab('Weekly');"
result <- data$remDr$executeScript(script, args = list())[[1]]
#wait
wait_till_IDloaded(data,"NTUHWeb1_WeeklySummaryMainTab_ucPAP_txbProblem1")
wait_till_IDloaded(data,"NTUHWeb1_WeeklySummaryMainTab_ucPAP_txbProblem2")
##
source("genWeeklyNote_content.R")
#Write content
script <- 'document.getElementById("NTUHWeb1_WeeklySummaryMainTab_ucPAP_txbProblem1").value = arguments[0];
document.getElementById("NTUHWeb1_WeeklySummaryMainTab_ucPAP_txbAssessment1").value = arguments[1];
document.getElementById("NTUHWeb1_WeeklySummaryMainTab_ucPAP_txbPlan1").value = arguments[2];
document.getElementById("NTUHWeb1_WeeklySummaryMainTab_ucPAP_txbProblem2").value = arguments[3];
document.getElementById("NTUHWeb1_WeeklySummaryMainTab_ucPAP_txbAssessment2").value = arguments[4];
document.getElementById("NTUHWeb1_WeeklySummaryMainTab_ucPAP_txbPlan2").value = arguments[5];
document.getElementById("NTUHWeb1_WeeklySummaryMainTab_txbBriefSummary").value = arguments[6];
document.getElementById("NTUHWeb1_WeeklySummaryMainTab_txbDiagnosis").value = arguments[7];'
trash <- data$remDr$executeScript(script, args = list(ProbDATA1,
AssessDATA1,
PlanDATA1,
ProbDATA2,
paste(VitalDATA,"\n",AssessDATA2,sep=""),
PlanDATA2,
WeeklySumTXT,
WeeklyDiagnosis))[[1]]
#save
#unknown bug that results in freezing sometimes....
doTillSuccess({
webElem7 <- data$remDr$findElement(using = "id", value = "NTUHWeb1_WeeklySummaryMainTab_btnSaveWeeklySummary")
webElem7$clickElement()
},data)
#wait till complete
wait_till_textappear(data, "NTUHWeb1_WeeklySummaryMainTab_lblShowMessage", "暫存成功",
15,{
data$remDr$navigate(PNlink)
data$remDr$refresh()
source("OpenNewAddWeeklyNote.R")
#wait
wait_till_IDloaded(data,"NTUHWeb1_WeeklySummaryMainTab_ucPAP_txbProblem1")
wait_till_IDloaded(data,"NTUHWeb1_WeeklySummaryMainTab_ucPAP_txbProblem2")
#Write content
script <- 'document.getElementById("NTUHWeb1_WeeklySummaryMainTab_ucPAP_txbProblem1").value = arguments[0];
document.getElementById("NTUHWeb1_WeeklySummaryMainTab_ucPAP_txbAssessment1").value = arguments[1];
document.getElementById("NTUHWeb1_WeeklySummaryMainTab_ucPAP_txbPlan1").value = arguments[2];
document.getElementById("NTUHWeb1_WeeklySummaryMainTab_ucPAP_txbProblem2").value = arguments[3];
document.getElementById("NTUHWeb1_WeeklySummaryMainTab_ucPAP_txbAssessment2").value = arguments[4];
document.getElementById("NTUHWeb1_WeeklySummaryMainTab_ucPAP_txbPlan2").value = arguments[5];
document.getElementById("NTUHWeb1_WeeklySummaryMainTab_txbBriefSummary").value = arguments[6];
document.getElementById("NTUHWeb1_WeeklySummaryMainTab_txbDiagnosis").value = arguments[7];'
trash <- data$remDr$executeScript(script, args = list(ProbDATA1,
AssessDATA1,
PlanDATA1,
ProbDATA2,
paste(VitalDATA,"\n",AssessDATA2,sep=""),
PlanDATA2,
WeeklySumTXT,
WeeklyDiagnosis))[[1]]
##
Sys.sleep(3)
##
webElem7 <- data$remDr$findElement(using = "id", value = "NTUHWeb1_WeeklySummaryMainTab_btnSaveWeeklySummary")
webElem7$clickElement()
})
#wait_till_ClassLoaded(data,"blockUI blockMsg blockPage")
#wait_till_ClassLoaded(data,"growlUI")
#wait_till_ClassDisappear(data,"growlUI")
##########################################
## add two free notes as progress notes ##
##########################################
for (PN.index in 1:as.numeric(PNnoteNum)){ #notes number determined by user - PNnoteNum
#for (PN.index in 1:4){ #four notes
#refresh
#Sys.sleep(1)
data$remDr$refresh()
data$remDr$navigate(PNlink)
wait_till_element(data$remDr, "NTUHWeb1_ProblemQueryByAccList1_btnDisplayInValidProblem")
#click add new progress note
Sys.sleep(1)
clickElement(data,"NTUHWeb1_btnInsertBlankNote")
Sys.sleep(1)
wait_till_steadystate(data,"/html/body", steadythres = 5)
#wait_till_IDloaded(data,"Layer1")
#
rootNode<-reloadHTML(data)
NoteList<-xpathSApply(rootNode,
'//*[@id="tblNoteList"]/tbody/tr/td[@class="helpBod helpTimeField pointerCursor"]',
xmlGetAttr, name = "title")
while (T){
if (length(NoteList)!=0){
newProgNote <- (grepl("請輸入標題", tolower(NoteList)) & grepl("暫存", tolower(NoteList)) &
(difftime(Sys.Date(),as.Date(sapply(NoteList,str_extract,"\\d\\d\\d\\d/\\d\\d?/\\d\\d?")),units = "days") == 0))  #bug for future notes
#to do the new added, must >0
if (sum(newProgNote)!=0) #if any is true
{ break } #break if complete - where there is "請輸入標題", "暫存" at today's date
}#end if
#
#Sys.sleep(2)
#
data$remDr$refresh()
wait_till_steadystate(data,"/html/body", steadythres = 5) #wait
##reload the page
data$remDr$navigate(PNlink)
wait_till_element(data$remDr, "NTUHWeb1_ProblemQueryByAccList1_btnDisplayInValidProblem")
#
rootNode<-reloadHTML(data)
NoteList<-xpathSApply(rootNode,
'//*[@id="tblNoteList"]/tbody/tr/td[@class="helpBod helpTimeField pointerCursor"]',
xmlGetAttr, name = "title")
}#end while
##Open newly added weeklyPN, write content and click save
source("open_writeNewWeekPN.R")
#wait till complete
wait_till_textappear(data,
"NTUHWeb1_BlankNoteMainTab_lblShowMessage",
"暫存成功",
15, {
#webElem9 <- data$remDr$findElement(using = "id", value = "NTUHWeb1_BlankNoteMainTab_btnSaveBlankNote")
#webElem9$clickElement()
data$remDr$refresh()
data$remDr$navigate(PNlink)
source("open_writeNewWeekPN.R")
})
#wait_till_ClassLoaded(data,"growlUI")
#wait_till_ClassDisappear(data,"growlUI")
}#end for how much PNs
##
}#end if ignore MBD within 24 hrs
}#end for
setwd("/Users/peishenwu/Google 雲端硬碟/【01】醫學/PMR/R2/排班/Planner")  ##modify the path here...
##by Pei-shen Wu, MD (2015)
##version 2015-12-21
options(stringsAsFactors = FALSE,
scipen=999) ##disable scientific number notation
set.seed(1234)
library(xlsx)
#library(utils)
library(compiler)
#
##do Iterations
iter_max = 300000
#
config.data <- read.xlsx("planner_config.xlsx", 1, row.names = NULL)
contraspace <- config.data[2:nrow(config.data),-c(1,2,ncol(config.data), (ncol(config.data)-1))]
persondata <- config.data[2:nrow(config.data),c(1,2)]
Encoding(persondata$name) <- "UTF-8"
strucdata <- config.data[2:nrow(config.data),c(ncol(config.data), (ncol(config.data)-1))]
holidays <- config.data[1,-c(1,2,ncol(config.data), (ncol(config.data)-1))]
holidays <- as.numeric(gsub("X","",names(holidays[,holidays == 1])))
contraspace_days <- as.numeric(gsub("X","",names(contraspace)))
junior_rowindex <- c(1:length(persondata$level))[persondata$level %in% c("R1","R2")]
senior_rowindex <- c(1:length(persondata$level))[persondata$level %in% c("R3","R4")]
##sort by complexity
sort.config.data <- data.frame(persondata, strucdata,
flexible_holidays = rep(Inf,nrow(contraspace)),
flexible_workdays = rep(Inf,nrow(contraspace)),
contraspace)
for(irow in 1:nrow(contraspace)){
availabledays <- contraspace[irow,]
availabledays <- contraspace_days[availabledays == 0]
available.holidays <- availabledays[(availabledays %in% holidays)]
available.workdays <- availabledays[!(availabledays %in% holidays)]
#
sort.config.data$flexible_holidays[irow] <- length(available.holidays) - strucdata$holidays[irow]
sort.config.data$flexible_workdays[irow] <- length(available.workdays) - strucdata$workdays[irow]
}#end for
sort.config.data <- sort.config.data[order(sort.config.data$flexible_holidays,
sort.config.data$flexible_workdays,
decreasing = F),]
contraspace <- sort.config.data[,-c(1:6)]
appointspace <- 1*(contraspace == 2)
contraspace <- contraspace - 2*appointspace
##
strucdata <- sort.config.data[, c(3,4)]
persondata <- sort.config.data[, c(1,2)]
##
appoint_holidays <- apply(appointspace[,holidays],1,sum)
appoint_workdays <- apply(appointspace[,-holidays],1,sum)
appoint_struc <- data.frame(workdays = appoint_workdays,
holidays = appoint_holidays)
## check for configuration error
if ((sum(sort.config.data$flexible_holidays < 0) + sum(sort.config.data$flexible_workdays < 0)) != 0){
stop("Error !! Someone set too much contras, leading to not enough available workdays or holidays")
}#end if
count_holidays <- length(holidays)
count_workdays <- length(contraspace_days) - count_holidays
if (sum(strucdata$workdays) != 2*count_workdays | sum(strucdata$holidays) != 2*count_holidays){
stop("Error in holidays or workdays configuration")
}#end if
## if more than two persons appoint the same day for on-duty, then it's an error
if (sum(apply(contraspace, 2, function(x){sum(x == 2)}) > 2) != 0){
stop("Error !! more than two persons appoint the same day for on-duty")
}#end if
##if appoint structure disobeys strucdata then it's an error
if ((sum(appoint_struc$holidays > strucdata$holidays)!=0) | (sum(appoint_struc$workdays > strucdata$workdays)!=0)){
message(paste("\nThere are more appointed holidays than previously determined in: ",
paste(persondata$name[appoint_struc$holidays > strucdata$holidays], collapse = ","), sep=""))
message(paste("\nThere are more appointed workdays than previously determined in: ",
paste(persondata$name[appoint_struc$workdays > strucdata$workdays], collapse = ","), sep=""))
stop("Process halted")
}#end if
##worker functions
getintervals <- function(x){
result = Inf
if (length(x) >1){
result = (sapply(2:length(x),function(i){x[i]-x[i-1]}))
}
result
}#end function
repeatdetect <- function(x, target){
result = 0
if (length(x)>1){
result <- sum(sapply(2:length(x),
function(i){
(x[i] == x[i-1]) * (x[i] == target)
}))
}
result
}#end function
#pb <- txtProgressBar(min = 1, max = iter_max, style=3)
#progress <- function(n){ setTxtProgressBar(pb, n) }
##
Algorithm <- function(contraspace_days, contraspace, iter_max, strucdata, holidays, appointspace){
count_iter = 0
results <- list()
iter_log <- rep(0,iter_max %/% 250)
##worker functions
mininterval <- function(x){
result = Inf
if (length(x) >1){
#result = min(sapply(2:length(x),function(i){x[i]-x[i-1]}))
result = min(x[2:length(x)] - x[1:length(x)-1]) #vectorized version
}
result
}#end function
##
init_time = Sys.time() #set time at beginning
avg_trials = c() ## for recording of HOW MUCH TRIALS ON AVERAGE FOR A SINGLE SOLUTION
##
while(T){ #do many iterations
count_iter = count_iter + 1
##
if (count_iter %% 250 == 0){
remaining.time <- round(((iter_max-count_iter)/count_iter)*as.numeric(difftime(Sys.time(),init_time,units="secs")))
progress.status <- round(count_iter*100/iter_max)
#cat("\014") #ctrl+L to clear screen in Rstudio console
if(.Platform$OS.type == "unix"){system('clear')} #to clear screen in mac OSX console
if(.Platform$OS.type == "windows"){
#system('cls')
cat(rep("\n",64))
} #to clear screen in windows DOS console
avg_trials <- c(avg_trials, (count_iter %/% length(results)))
avg_trials <- avg_trials[avg_trials != Inf]
cat(paste("\nIteration: ",count_iter," of total ",iter_max,
"\nRemaining time: ",
(remaining.time%/%3600)," hrs ",
(remaining.time%%3600%/%60)," min ",
(remaining.time%%3600%%60)," sec ",
"\nObtained: ",length(results),
"\nAverage yield: 1 solution per ",round(mean(avg_trials))," trials",
"\n",paste("|",paste(rep("=",round(progress.status*0.6)),collapse=""),
paste(rep(" ",round((100-progress.status)*0.6)),collapse=""),"| ",
progress.status,"%",sep=""),
sep=""))
#progress(count_iter) #update progress bar status
iter_log[count_iter %/% 250+1] <- length(results)
}
##
if(count_iter > iter_max){break} #exit iteration if completed
#renew workspace and contraspace.updated
#workspace <- matrix(data=0, nrow = nrow(contraspace), ncol = ncol(contraspace))
workspace <- appointspace ##initialize with appointment space
contraspace.updated <- (contraspace | appointspace)*1
##update contraspace if 2 duties exist per day (do this first, because it can be filled by appointment)
contraspace.updated[,(apply(workspace,2,sum) == 2)] <- 1
##Planner algorithm
skip = F
for(irow in 1:nrow(workspace)){
availabledays <- contraspace.updated[irow,]
availabledays <- contraspace_days[availabledays != 1]
##identify which workday/holiday had been appointed prior
holiday.appointed <- contraspace_days[appointspace[irow,]==1][holidays]
holiday.appointed <- holiday.appointed[complete.cases(holiday.appointed)]
workday.appointed <- contraspace_days[appointspace[irow,]==1][-holidays]
workday.appointed <- workday.appointed[complete.cases(workday.appointed)]
##reset
holiday.to.fill <- NULL
workday.to.fill <- NULL
##
if (strucdata$holidays[irow]!=0){
available.holidays <- availabledays[(availabledays %in% holidays)]
if((length(available.holidays) == 0) | (length(available.holidays) < strucdata$holidays[irow])){
skip <- T
break #exit for loop
}else{
holiday.to.fill <- c(holiday.appointed, available.holidays)
if(length(available.holidays)>1){ #only sample when there is more than one choice
holiday.to.fill <- c(holiday.appointed,
sample(available.holidays, strucdata$holidays[irow] - appoint_struc$holidays[irow]))
}#end if
}#end if
}#end if
if (strucdata$workdays[irow]!=0){
available.workdays <- availabledays[!(availabledays %in% holidays)]
if((length(available.workdays) == 0) | (length(available.workdays) < strucdata$workdays[irow])){
skip <- T
break #exit for loop
}else{
workday.to.fill <- c(workday.appointed, available.workdays)
if(length(available.workdays)>1){ #only sample when there is more than one choice
workday.to.fill <- c(workday.appointed,
sample(available.workdays, strucdata$workdays[irow] - appoint_struc$workdays[irow]))
}#end if
}#end if
}#end if
##
if (length(holiday.to.fill)!=0){
workspace[irow, c(holiday.to.fill)] <- 1
}#end if
if (length(workday.to.fill)!=0){
workspace[irow, c(workday.to.fill)] <- 1
}#end if
##update contraspace if 2 duties exist per day
contraspace.updated[,(apply(workspace,2,sum) == 2)] <- 1
##update contraspace according to strucdata status
contraspace.updated[apply(workspace[,c(holidays)],1,sum) == strucdata$holidays, c(holidays)] <- 1 ##if already match holiday struc for every person
contraspace.updated[apply(workspace[,-c(holidays)],1,sum) == strucdata$workdays, -c(holidays)] <- 1 ##if already match workday struc for every person
##
#
}#end for
#
if(skip){
next  ##next iteration
}else{
##check for errors and contraindications
error = F
## every shift interval is at least >= 1 to prevent QD, can manually adjust)
min.int <- sapply(1:nrow(workspace),
function(x){
mininterval(c(1:ncol(workspace))[c(workspace[x,]==1)])
})
if (sum(min.int>1) != nrow(workspace)){error = T}
## check if holidays and workdays all follow strucdata
#if (sum(apply(workspace[,c(holidays)],1,sum) != strucdata$holidays) != 0
#    | sum(apply(workspace[,-c(holidays)],1,sum) != strucdata$workdays) != 0){error = T}
##if no error then aggregate result
if (!error){
results <- c(results, list(workspace))
}#end if
}#end if
}#end of iteration
##
list(results = results,
iter_log = iter_log)
}#end of Algorithm
##
cAlgorithm <- cmpfun(Algorithm) ##use compiler for faster performance
output <- cAlgorithm(contraspace_days, contraspace, iter_max, strucdata, holidays, appointspace)
avg_trials
