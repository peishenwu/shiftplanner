#
##do Iterations
iter_max = 200000
config.data <- read.xlsx("planner_config.xlsx", 1, row.names = NULL)
contraspace <- config.data[2:nrow(config.data),-c(1,2,ncol(config.data), (ncol(config.data)-1))]
View(config.data)
View(contraspace)
persondata <- config.data[2:nrow(config.data),c(1,2)]
Encoding(persondata$name) <- "UTF-8"
strucdata <- config.data[2:nrow(config.data),c(ncol(config.data), (ncol(config.data)-1))]
holidays <- config.data[1,-c(1,2,ncol(config.data), (ncol(config.data)-1))]
holidays <- as.numeric(gsub("X","",names(holidays[,holidays == 1])))
View(strucdata)
View(contraspace)
contraspace_days <- as.numeric(gsub("X","",names(contraspace)))
junior_rowindex <- c(1:length(persondata$level))[persondata$level %in% c("R1","R2")]
senior_rowindex <- c(1:length(persondata$level))[persondata$level %in% c("R3","R4")]
sort.config.data <- data.frame(persondata, strucdata,
flexible_holidays = rep(Inf,nrow(contraspace)),
flexible_workdays = rep(Inf,nrow(contraspace)),
contraspace)
for(irow in 1:nrow(contraspace)){
availabledays <- contraspace[irow,]
availabledays <- contraspace_days[availabledays == 0]
available.holidays <- availabledays[(availabledays %in% holidays)]
available.workdays <- availabledays[!(availabledays %in% holidays)]
#
sort.config.data$flexible_holidays[irow] <- length(available.holidays) - strucdata$holidays[irow]
sort.config.data$flexible_workdays[irow] <- length(available.workdays) - strucdata$workdays[irow]
}#end for
View(sort.config.data)
irow=7
contraspace[irow,]
availabledays <- contraspace[irow,]
availabledays <- contraspace_days[availabledays == 0]
available.holidays <- availabledays[(availabledays %in% holidays)]
available.workdays <- availabledays[!(availabledays %in% holidays)]
availabledays
sort.config.data <- sort.config.data[order(sort.config.data$flexible_holidays,
sort.config.data$flexible_workdays,
decreasing = F),]
contraspace <- sort.config.data[,-c(1:6)]
strucdata <- sort.config.data[, c(3,4)]
persondata <- sort.config.data[, c(1,2)]
View(contraspace)
?apply
apply(contraspace, 2, function(x){sum(x == 2)})
sum(apply(contraspace, 2, function(x){sum(x == 2)}) > 2)
View(strucdata)
View(contraspace)
contraspace
contraspace == 2
1*(contraspace == 2)
appointspace <- 1*(contraspace == 2)
appointspace[,holidays]
apply(appointspace[,holidays],1,sum)
appoint_holiday <- apply(appointspace[,holidays],1,sum)
appoint_workday <- apply(appointspace[,-holidays],1,sum)
appoint_workday
strucdata
strucdata$holidays
strucdata$workdays
appoint_holidays <- apply(appointspace[,holidays],1,sum)
appoint_workdays <- apply(appointspace[,-holidays],1,sum)
strucdata$holidays <- strucdata$holidays - appoint_holidays
strucdata$weekdays <- strucdata$weekdays - appoint_weekdays
strucdata <- sort.config.data[, c(3,4)]
persondata <- sort.config.data[, c(1,2)]
## update strucdata according to appointing specific days for on-duty
appoint_holidays <- apply(appointspace[,holidays],1,sum)
appoint_workdays <- apply(appointspace[,-holidays],1,sum)
strucdata$holidays <- strucdata$holidays - appoint_holidays
strucdata$workdays <- strucdata$workdays - appoint_wordays
contraspace <- sort.config.data[,-c(1:6)]
appointspace <- 1*(contraspace == 2)
##
strucdata <- sort.config.data[, c(3,4)]
persondata <- sort.config.data[, c(1,2)]
## update strucdata according to appointing specific days for on-duty
appoint_holidays <- apply(appointspace[,holidays],1,sum)
appoint_workdays <- apply(appointspace[,-holidays],1,sum)
strucdata$holidays <- strucdata$holidays - appoint_holidays
strucdata$workdays <- strucdata$workdays - appoint_workdays
View(strucdata)
View(strucdata)
msg <- try({source("planner.R")},F)[1]
if(length(msg)!=0){
if(grepl("error",tolower(msg))){
stop("\nNo results were obtained... thus process halted")
}
}
msg <- try({source("planner.R")},F)[1]
msg <- try({source("planner.R")},F)[1]
if(length(msg)!=0){
if(grepl("error",tolower(msg))){
stop("\nNo results were obtained... thus process halted")
}
}
contraspace
appointspace
msg <- try({source("planner.R")},F)[1]
workspace <- appointspace ##initialize with appointment space
contraspace.updated <- contraspace
##update contraspace if 2 duties exist per day (do this first, because it can be filled by appointment)
contraspace.updated[,(apply(workspace,2,sum) == 2)] <- 1
View(contraspace.updated)
workspace
contraspace
msg <- try({source("planner.R")},F)[1]
contraspace | appointspace
(contraspace | appointspace)*1
appointspace
(contraspace)
View(config.data)
contraspace <- sort.config.data[,-c(1:6)]
appointspace <- 1*(contraspace == 2)
contraspace <- contraspace - 2*appointspace
View(contraspace)
msg <- try({source("planner.R")},F)[1]
if(length(msg)!=0){
if(grepl("error",tolower(msg))){
stop("\nNo results were obtained... thus process halted")
}
}
test <- readRDS("planner_output.rds")
str(test)
names(test)
View(test$results[[1]])
View(test$results[[2]])
saveRDS(list(contraspace = contraspace,
strucdata = strucdata,
results = results,
quality = quality,
iter_log = iter_log,
iter_max = iter_max,
holidays = holidays,
appointspace = appointspace,
contraspace_days=contraspace_days),
"planner_output.rds")
appointspace
data <- readRDS("planner_output.rds")
options(stringsAsFactors = FALSE,
scipen=999)
library(utils)
library(doSNOW)
message("initalizing parallel threads...")
cl <- makeSOCKcluster(20)
registerDoSNOW(cl)
##
data <- readRDS("planner_output.rds")
results <- data$results
contraspace <- data$contraspace[,-c(1,2)] #remove names, levels columns
holidays <- data$holidays
contraspace_days <- data$contraspace_days
persondata <- data$contraspace[, c(1,2)]
strucdata <- data$strucdata
appointspace <- data$appointspace
junior_rowindex <- c(1:length(persondata$level))[persondata$level %in% c("R1","R2")]
senior_rowindex <- c(1:length(persondata$level))[persondata$level %in% c("R3","R4")]
##worker functions
mininterval <- function(x){
result = Inf
if (length(x) >1){
#result = min(sapply(2:length(x),function(i){x[i]-x[i-1]}))
result = min(x[2:length(x)] - x[1:length(x)-1]) #vectorized version
}
result
}#end function
getintervals <- function(x){
result = Inf
if (length(x) >1){
result = (sapply(2:length(x),function(i){x[i]-x[i-1]}))
}
result
}#end function
repeatdetect <- function(x, target){
result = 0
if (length(x)>1){
result <- sum(sapply(2:length(x),
function(i){
(x[i] == x[i-1]) * (x[i] == target)
}))
}
result
}#end function
#
swap.Agg <- c()
ritem
ritem=1
swap.Agg <- c()
for(ritem in 1:length(results)){
message(paste("\nWorking on result ",ritem,"/",length(results),sep=""))
##Prepare swap space
swapspace <- data.frame(p.index = NA, day = NA, HorW = NA)
for(p.index in 1:nrow(results[[ritem]])){
dutydays <- contraspace_days[results[[ritem]][p.index,-c(1,2)] == 1]
dutyholidays <- dutydays[dutydays %in% holidays]
dutyworkdays <- dutydays[!(dutydays %in% holidays)]
#
swapspace <- rbind(swapspace,
data.frame(p.index = rep(p.index, length(dutyholidays)),
day = dutyholidays,
HorW = rep(1, length(dutyholidays))),
data.frame(p.index = rep(p.index, length(dutyworkdays)),
day = dutyworkdays,
HorW = rep(2, length(dutyworkdays))))
}#end for
swapspace <- swapspace[complete.cases(swapspace),]
##1 for Holiday, 2 for Workday
for(HW.index in 1:2){
#message(paste("Working on ",c("holidays","workdays")[HW.index],sep=""))
swapwork <- swapspace[swapspace$HorW == HW.index,]
swapcomb <- combn(1:nrow(swapwork),2)
#
pb <- txtProgressBar(min = 1, max = ncol(swapcomb), style=3)
progress <- function(n){ setTxtProgressBar(pb, n) }
opts <- list(progress=progress)
#parallel approach for faster performance...
swap.result  <- foreach(comb.index = 1:ncol(swapcomb), .options.snow=opts) %dopar% {
foreach.result = NA
#skip if the days or person are the same
if((swapwork$day[swapcomb[1,comb.index]] != swapwork$day[swapcomb[2,comb.index]])
&(swapwork$p.index[swapcomb[1,comb.index]] != swapwork$p.index[swapcomb[2,comb.index]])){
#check if swap contra exists
if((contraspace[swapwork$p.index[swapcomb[1,comb.index]],swapwork$day[swapcomb[2,comb.index]]]!=1)
&(contraspace[swapwork$p.index[swapcomb[2,comb.index]],swapwork$day[swapcomb[1,comb.index]]]!=1)){
#swap if not skipped
workspace <- results[[ritem]][,-c(1,2)]
workspace[swapwork$p.index[swapcomb[1,comb.index]],swapwork$day[swapcomb[2,comb.index]]] <- 1
workspace[swapwork$p.index[swapcomb[2,comb.index]],swapwork$day[swapcomb[1,comb.index]]] <- 1
workspace[swapwork$p.index[swapcomb[1,comb.index]],swapwork$day[swapcomb[1,comb.index]]] <- 0
workspace[swapwork$p.index[swapcomb[2,comb.index]],swapwork$day[swapcomb[2,comb.index]]] <- 0
#check for any errors such as QDs
min.int <- sapply(1:nrow(workspace),
function(x){
mininterval(c(1:ncol(workspace))[c(workspace[x,]==1)])
})
if (sum(min.int>1) == nrow(workspace)){
#if no errors then save swapped result
foreach.result <- workspace
}#end if
}#end if
}#end if
foreach.result
}#end foreach combination
##remove NAs
rswap.result <- c()
for (rswap.index in 1:length(swap.result)){
if(identical(swap.result[[rswap.index]], NA)){next}
rswap.result <- c(rswap.result, list(swap.result[[rswap.index]]))
}#end for if NAs
##
swap.Agg <- c(swap.Agg, rswap.result)
}#end for HW.index
}#end for every results
quality
msg <- try({source("planner.R")},F)[1]
if(length(msg)!=0){
if(grepl("error",tolower(msg))){
stop("\nNo results were obtained... thus process halted")
}
}
View(quality)
options(stringsAsFactors = FALSE,
scipen=999)
library(utils)
library(doSNOW)
message("initalizing parallel threads...")
cl <- makeSOCKcluster(20)
registerDoSNOW(cl)
##
data <- readRDS("planner_output.rds")
results <- data$results
contraspace <- data$contraspace[,-c(1,2)] #remove names, levels columns
holidays <- data$holidays
contraspace_days <- data$contraspace_days
persondata <- data$contraspace[, c(1,2)]
strucdata <- data$strucdata
appointspace <- data$appointspace
junior_rowindex <- c(1:length(persondata$level))[persondata$level %in% c("R1","R2")]
senior_rowindex <- c(1:length(persondata$level))[persondata$level %in% c("R3","R4")]
##worker functions
mininterval <- function(x){
result = Inf
if (length(x) >1){
#result = min(sapply(2:length(x),function(i){x[i]-x[i-1]}))
result = min(x[2:length(x)] - x[1:length(x)-1]) #vectorized version
}
result
}#end function
getintervals <- function(x){
result = Inf
if (length(x) >1){
result = (sapply(2:length(x),function(i){x[i]-x[i-1]}))
}
result
}#end function
repeatdetect <- function(x, target){
result = 0
if (length(x)>1){
result <- sum(sapply(2:length(x),
function(i){
(x[i] == x[i-1]) * (x[i] == target)
}))
}
result
}#end function
#
swap.Agg <- c()
for(ritem in 1:length(results)){
message(paste("\nWorking on result ",ritem,"/",length(results),sep=""))
##Prepare swap space
swapspace <- data.frame(p.index = NA, day = NA, HorW = NA)
for(p.index in 1:nrow(results[[ritem]])){
dutydays <- contraspace_days[results[[ritem]][p.index,-c(1,2)] == 1]
dutyholidays <- dutydays[dutydays %in% holidays]
dutyworkdays <- dutydays[!(dutydays %in% holidays)]
#
swapspace <- rbind(swapspace,
data.frame(p.index = rep(p.index, length(dutyholidays)),
day = dutyholidays,
HorW = rep(1, length(dutyholidays))),
data.frame(p.index = rep(p.index, length(dutyworkdays)),
day = dutyworkdays,
HorW = rep(2, length(dutyworkdays))))
}#end for
swapspace <- swapspace[complete.cases(swapspace),]
##1 for Holiday, 2 for Workday
for(HW.index in 1:2){
#message(paste("Working on ",c("holidays","workdays")[HW.index],sep=""))
swapwork <- swapspace[swapspace$HorW == HW.index,]
swapcomb <- combn(1:nrow(swapwork),2)
#
pb <- txtProgressBar(min = 1, max = ncol(swapcomb), style=3)
progress <- function(n){ setTxtProgressBar(pb, n) }
opts <- list(progress=progress)
#parallel approach for faster performance...
swap.result  <- foreach(comb.index = 1:ncol(swapcomb), .options.snow=opts) %dopar% {
foreach.result = NA
#skip if the days or person are the same
if((swapwork$day[swapcomb[1,comb.index]] != swapwork$day[swapcomb[2,comb.index]])
&(swapwork$p.index[swapcomb[1,comb.index]] != swapwork$p.index[swapcomb[2,comb.index]])){
#check if swap contra exists
if((contraspace[swapwork$p.index[swapcomb[1,comb.index]],swapwork$day[swapcomb[2,comb.index]]]!=1)
&(contraspace[swapwork$p.index[swapcomb[2,comb.index]],swapwork$day[swapcomb[1,comb.index]]]!=1)){
#swap if not skipped
workspace <- results[[ritem]][,-c(1,2)]
workspace[swapwork$p.index[swapcomb[1,comb.index]],swapwork$day[swapcomb[2,comb.index]]] <- 1
workspace[swapwork$p.index[swapcomb[2,comb.index]],swapwork$day[swapcomb[1,comb.index]]] <- 1
workspace[swapwork$p.index[swapcomb[1,comb.index]],swapwork$day[swapcomb[1,comb.index]]] <- 0
workspace[swapwork$p.index[swapcomb[2,comb.index]],swapwork$day[swapcomb[2,comb.index]]] <- 0
#check for any errors such as QDs
min.int <- sapply(1:nrow(workspace),
function(x){
mininterval(c(1:ncol(workspace))[c(workspace[x,]==1)])
})
if (sum(min.int>1) == nrow(workspace)){
#if no errors then save swapped result
foreach.result <- workspace
}#end if
}#end if
}#end if
foreach.result
}#end foreach combination
##remove NAs
rswap.result <- c()
for (rswap.index in 1:length(swap.result)){
if(identical(swap.result[[rswap.index]], NA)){next}
rswap.result <- c(rswap.result, list(swap.result[[rswap.index]]))
}#end for if NAs
##
swap.Agg <- c(swap.Agg, rswap.result)
}#end for HW.index
}#end for every results
##calculate qualities of post-swapped results and pre-swapped results
##remove names and level columns
r.results <- c()
for(r.index in 1:length(results)){
r.results <- c(r.results, list(results[[r.index]][,-c(1,2)]))
}
results <- c(r.results,swap.Agg)
##calculate quality metrics
## 1. counts of QODs
## 2. discreteness of shifts
## 3. number of days where "senior residents on duty = 2 personale"
## 4. number of continuous QODs
quality <- data.frame(resultIndex = 1:length(results),
cQODs = rep(NA,length(results)),
discrete = rep(NA,length(results)),
cSenior = rep(NA,length(results)),
continQODs = rep(NA,length(results)),
NoContras = rep(NA, length(results)),
NotFollowHoliday = rep(NA, length(results)),
NotFollowWorkday = rep(NA, length(results)),
OnlyTwoDutiesPerDay = rep(NA, length(results)))
pb <- txtProgressBar(min = 1, max = length(results), style=3)
message("\nCalculating quality...")
for (item in 1:length(results)){
progress(item)
#
quality$cSenior[item] <- sum(apply(results[[item]][senior_rowindex,],2,sum) == 2)
quality$discrete[item] <- min(apply(results[[item]],1,
function(x){
mean(getintervals(c(1:ncol(results[[item]]))[x == 1]))
}))
quality$cQODs[item] <- sum(apply(results[[item]],1,
function(x){
sum(getintervals(c(1:ncol(results[[item]]))[x == 1]) == 2)
}))
quality$continQODs[item] <- sum(apply(results[[item]],1,
function(x){
repeatdetect(getintervals(c(1:ncol(results[[item]]))[x == 1]),2)
}))
quality$NoContras[item] <- (sum((contraspace + results[[item]]) == 2) == 0)
quality$NotFollowHoliday[item] <- sum(apply(results[[item]][,c(holidays)],1,sum) != strucdata$holidays)
quality$NotFollowWorkday[item] <- sum(apply(results[[item]][,-c(holidays)],1,sum) != strucdata$workdays)
quality$OnlyTwoDutiesPerDay[item] <- sum(apply(results[[item]],2,sum) != 2)
}#end for
#remove those which don't obey strucdata or only two duties per day or has contras
#also only show those without continuous QODs
quality <- quality[quality$NoContras == T &
quality$NotFollowHoliday == 0 &
quality$NotFollowWorkday == 0 &
quality$OnlyTwoDutiesPerDay == 0 &
quality$continQODs == 0 &
quality$cSenior == 0,]
quality <- quality[order(quality$cQODs,
quality$cSenior,
-quality$discrete,
decreasing = F),]
warnings()
View(quality)
length(results)
contraspace
appointspace
quality <- data.frame(resultIndex = 1:length(results),
cQODs = rep(NA,length(results)),
discrete = rep(NA,length(results)),
cSenior = rep(NA,length(results)),
continQODs = rep(NA,length(results)),
NoContras = rep(NA, length(results)),
NotFollowHoliday = rep(NA, length(results)),
NotFollowWorkday = rep(NA, length(results)),
OnlyTwoDutiesPerDay = rep(NA, length(results)))
pb <- txtProgressBar(min = 1, max = length(results), style=3)
message("\nCalculating quality...")
for (item in 1:length(results)){
progress(item)
#
quality$cSenior[item] <- sum(apply(results[[item]][senior_rowindex,],2,sum) == 2)
quality$discrete[item] <- min(apply(results[[item]],1,
function(x){
mean(getintervals(c(1:ncol(results[[item]]))[x == 1]))
}))
quality$cQODs[item] <- sum(apply(results[[item]],1,
function(x){
sum(getintervals(c(1:ncol(results[[item]]))[x == 1]) == 2)
}))
quality$continQODs[item] <- sum(apply(results[[item]],1,
function(x){
repeatdetect(getintervals(c(1:ncol(results[[item]]))[x == 1]),2)
}))
quality$NoContras[item] <- (sum((contraspace + results[[item]]) == 2) == 0)
quality$NotFollowHoliday[item] <- sum(apply(results[[item]][,c(holidays)],1,sum) != strucdata$holidays)
quality$NotFollowWorkday[item] <- sum(apply(results[[item]][,-c(holidays)],1,sum) != strucdata$workdays)
quality$OnlyTwoDutiesPerDay[item] <- sum(apply(results[[item]],2,sum) != 2)
}#end for
View(quality)
results[[1]]
results[[1]] == appointspace
results[[1]] & appointspace
(results[[1]] & appointspace) == appointspace
View(appointspace)
View(results[[1]])
sum((results[[1]] & appointspace) != appointspace)
sum((results[[1]] & appointspace) != appointspace) != 0
sum((results[[item]] & appointspace) != appointspace) == 0
quality <- data.frame(resultIndex = 1:length(results),
cQODs = rep(NA,length(results)),
discrete = rep(NA,length(results)),
cSenior = rep(NA,length(results)),
continQODs = rep(NA,length(results)),
NoContras = rep(NA, length(results)),
NotFollowHoliday = rep(NA, length(results)),
NotFollowWorkday = rep(NA, length(results)),
OnlyTwoDutiesPerDay = rep(NA, length(results)),
FollowAllAppointments = rep(NA, length(results)))
pb <- txtProgressBar(min = 1, max = length(results), style=3)
message("\nCalculating quality...")
for (item in 1:length(results)){
progress(item)
#
quality$cSenior[item] <- sum(apply(results[[item]][senior_rowindex,],2,sum) == 2)
quality$discrete[item] <- min(apply(results[[item]],1,
function(x){
mean(getintervals(c(1:ncol(results[[item]]))[x == 1]))
}))
quality$cQODs[item] <- sum(apply(results[[item]],1,
function(x){
sum(getintervals(c(1:ncol(results[[item]]))[x == 1]) == 2)
}))
quality$continQODs[item] <- sum(apply(results[[item]],1,
function(x){
repeatdetect(getintervals(c(1:ncol(results[[item]]))[x == 1]),2)
}))
quality$NoContras[item] <- (sum((contraspace + results[[item]]) == 2) == 0)
quality$NotFollowHoliday[item] <- sum(apply(results[[item]][,c(holidays)],1,sum) != strucdata$holidays)
quality$NotFollowWorkday[item] <- sum(apply(results[[item]][,-c(holidays)],1,sum) != strucdata$workdays)
quality$OnlyTwoDutiesPerDay[item] <- sum(apply(results[[item]],2,sum) != 2)
quality$FollowAllAppointments[item] <- sum((results[[item]] & appointspace) != appointspace) == 0
}#end for
View(quality)
