p.index.done <- c()
##
for(irow in 1:nrow(workspace)){  ##do every personale
##re-calculate complexity when done with every previous personale to determine who's next...
##sort by complexity
resort.config.data <- data.frame(persondata, strucdata,
flexible_holidays = rep(Inf,nrow(contraspace)),
flexible_workdays = rep(Inf,nrow(contraspace)),
complexity = rep(Inf,nrow(contraspace)))
for(indexrow in 1:nrow(resort.config.data)){
availabledays <- contraspace.updated[indexrow,]
availabledays <- contraspace_days[availabledays == 0]
available.holidays <- availabledays[(availabledays %in% holidays)]
available.workdays <- availabledays[!(availabledays %in% holidays)]
#
resort.config.data$flexible_holidays[indexrow] <- length(available.holidays) - (strucdata$holidays[indexrow] - appoint_holidays[indexrow])
resort.config.data$flexible_workdays[indexrow] <- length(available.workdays) - (strucdata$workdays[indexrow] - appoint_workdays[indexrow])
resort.config.data$complexity[indexrow] <- min(c(resort.config.data$flexible_holidays[indexrow],
resort.config.data$flexible_workdays[indexrow]))
}#end for
if(length(p.index.done)!=0){
resort.config.data <- resort.config.data[-p.index.done,] ##select only the remaining personale
}#end if
##skip if there is complexity < 0
if(sum(resort.config.data$complexity < 0) != 0){
skip <- T
break #exit for loop
}#end if
##
resort.config.data <- resort.config.data[order(resort.config.data$complexity, decreasing = F),]
## identify the index of which personale to do next
if (irow != 1){
min_complexity <- resort.config.data$complexity[1]
min_names <- resort.config.data$name[resort.config.data$complexity %in% min_complexity]
next.p.index <- c(1:nrow(persondata))[persondata$name %in%  min_names]
if(length(next.p.index)>1){ next.p.index <- sample(next.p.index, 1) }
}else{
next.p.index <- sample(1:nrow(workspace), 1) ##start with a random personale
}#end if
p.index.done <- c(p.index.done, next.p.index)
#### plan personale according to next.p.index
availabledays <- contraspace.updated[next.p.index,]
availabledays <- contraspace_days[availabledays != 1]
##identify which workday/holiday had been appointed prior
holiday.appointed <- holidays[holidays %in% contraspace_days[appointspace[next.p.index,]==1]]
workdays <- contraspace_days[-holidays]
workday.appointed <- workdays[workdays %in% contraspace_days[appointspace[next.p.index,]==1]]
##reset
holiday.to.fill <- NULL
workday.to.fill <- NULL
##
if (strucdata$holidays[next.p.index]!=0){
available.holidays <- availabledays[(availabledays %in% holidays)]
if(((length(available.holidays)+length(holiday.appointed)) < strucdata$holidays[next.p.index]) |
(length(available.holidays)+length(holiday.appointed)) == 0){
skip <- T
break #exit for loop
}else{
holiday.to.fill <- c(holiday.appointed, available.holidays)
if(length(available.holidays)>1){ #only sample when there is more than one choice
holiday.to.fill <- c(holiday.appointed,
sample(available.holidays, strucdata$holidays[next.p.index] - appoint_struc$holidays[next.p.index]))
}#end if
}#end if
}#end if
if (strucdata$workdays[next.p.index]!=0){
available.workdays <- availabledays[!(availabledays %in% holidays)]
if(((length(available.workdays)+length(workday.appointed)) < strucdata$workdays[next.p.index]) |
(length(available.workdays)+length(workday.appointed)) == 0){
skip <- T
break #exit for loop
}else{
workday.to.fill <- c(workday.appointed, available.workdays)
if(length(available.workdays)>1){ #only sample when there is more than one choice
workday.to.fill <- c(workday.appointed,
sample(available.workdays, strucdata$workdays[next.p.index] - appoint_struc$workdays[next.p.index]))
}#end if
}#end if
}#end if
##
if (length(holiday.to.fill)!=0){
workspace[next.p.index, c(holiday.to.fill)] <- 1
}#end if
if (length(workday.to.fill)!=0){
workspace[next.p.index, c(workday.to.fill)] <- 1
}#end if
##update contraspace if 2 duties exist per day
contraspace.updated[,(apply(workspace,2,sum) == 2)] <- 1
##update contraspace according to strucdata status
contraspace.updated[apply(workspace[,c(holidays)],1,sum) == strucdata$holidays, c(holidays)] <- 1 ##if already match holiday struc for every person
contraspace.updated[apply(workspace[,-c(holidays)],1,sum) == strucdata$workdays, -c(holidays)] <- 1 ##if already match workday struc for every person
##
#
}#end for
#
workspace <- appointspace ##initialize with appointment space
contraspace.updated <- (contraspace | appointspace)*1
##update contraspace if 2 duties exist per day (do this first, because it can be filled by appointment)
contraspace.updated[,(apply(workspace,2,sum) == 2)] <- 1
##Planner algorithm
skip = F
##record which personale was done....
p.index.done <- c()
##
for(irow in 1:nrow(workspace)){  ##do every personale
##re-calculate complexity when done with every previous personale to determine who's next...
##sort by complexity
resort.config.data <- data.frame(persondata, strucdata,
flexible_holidays = rep(Inf,nrow(contraspace)),
flexible_workdays = rep(Inf,nrow(contraspace)),
complexity = rep(Inf,nrow(contraspace)))
for(indexrow in 1:nrow(resort.config.data)){
availabledays <- contraspace.updated[indexrow,]
availabledays <- contraspace_days[availabledays == 0]
available.holidays <- availabledays[(availabledays %in% holidays)]
available.workdays <- availabledays[!(availabledays %in% holidays)]
#
resort.config.data$flexible_holidays[indexrow] <- length(available.holidays) - (strucdata$holidays[indexrow] - appoint_holidays[indexrow])
resort.config.data$flexible_workdays[indexrow] <- length(available.workdays) - (strucdata$workdays[indexrow] - appoint_workdays[indexrow])
resort.config.data$complexity[indexrow] <- min(c(resort.config.data$flexible_holidays[indexrow],
resort.config.data$flexible_workdays[indexrow]))
}#end for
if(length(p.index.done)!=0){
resort.config.data <- resort.config.data[-p.index.done,] ##select only the remaining personale
}#end if
##skip if there is complexity < 0
if(sum(resort.config.data$complexity < 0) != 0){
skip <- T
break #exit for loop
}#end if
##
resort.config.data <- resort.config.data[order(resort.config.data$complexity, decreasing = F),]
## identify the index of which personale to do next
if (irow != 1){
min_complexity <- resort.config.data$complexity[1]
min_names <- resort.config.data$name[resort.config.data$complexity %in% min_complexity]
next.p.index <- c(1:nrow(persondata))[persondata$name %in%  min_names]
if(length(next.p.index)>1){ next.p.index <- sample(next.p.index, 1) }
}else{
next.p.index <- sample(1:nrow(workspace), 1) ##start with a random personale
}#end if
p.index.done <- c(p.index.done, next.p.index)
#### plan personale according to next.p.index
availabledays <- contraspace.updated[next.p.index,]
availabledays <- contraspace_days[availabledays != 1]
##identify which workday/holiday had been appointed prior
holiday.appointed <- holidays[holidays %in% contraspace_days[appointspace[next.p.index,]==1]]
workdays <- contraspace_days[-holidays]
workday.appointed <- workdays[workdays %in% contraspace_days[appointspace[next.p.index,]==1]]
##reset
holiday.to.fill <- NULL
workday.to.fill <- NULL
##
if (strucdata$holidays[next.p.index]!=0){
available.holidays <- availabledays[(availabledays %in% holidays)]
if(((length(available.holidays)+length(holiday.appointed)) < strucdata$holidays[next.p.index]) |
(length(available.holidays)+length(holiday.appointed)) == 0){
skip <- T
break #exit for loop
}else{
holiday.to.fill <- c(holiday.appointed, available.holidays)
if(length(available.holidays)>1){ #only sample when there is more than one choice
holiday.to.fill <- c(holiday.appointed,
sample(available.holidays, strucdata$holidays[next.p.index] - appoint_struc$holidays[next.p.index]))
}#end if
}#end if
}#end if
if (strucdata$workdays[next.p.index]!=0){
available.workdays <- availabledays[!(availabledays %in% holidays)]
if(((length(available.workdays)+length(workday.appointed)) < strucdata$workdays[next.p.index]) |
(length(available.workdays)+length(workday.appointed)) == 0){
skip <- T
break #exit for loop
}else{
workday.to.fill <- c(workday.appointed, available.workdays)
if(length(available.workdays)>1){ #only sample when there is more than one choice
workday.to.fill <- c(workday.appointed,
sample(available.workdays, strucdata$workdays[next.p.index] - appoint_struc$workdays[next.p.index]))
}#end if
}#end if
}#end if
##
if (length(holiday.to.fill)!=0){
workspace[next.p.index, c(holiday.to.fill)] <- 1
}#end if
if (length(workday.to.fill)!=0){
workspace[next.p.index, c(workday.to.fill)] <- 1
}#end if
##update contraspace if 2 duties exist per day
contraspace.updated[,(apply(workspace,2,sum) == 2)] <- 1
##update contraspace according to strucdata status
contraspace.updated[apply(workspace[,c(holidays)],1,sum) == strucdata$holidays, c(holidays)] <- 1 ##if already match holiday struc for every person
contraspace.updated[apply(workspace[,-c(holidays)],1,sum) == strucdata$workdays, -c(holidays)] <- 1 ##if already match workday struc for every person
##
#
}#end for
#
workspace <- appointspace ##initialize with appointment space
contraspace.updated <- (contraspace | appointspace)*1
##update contraspace if 2 duties exist per day (do this first, because it can be filled by appointment)
contraspace.updated[,(apply(workspace,2,sum) == 2)] <- 1
##Planner algorithm
skip = F
##record which personale was done....
p.index.done <- c()
##
for(irow in 1:nrow(workspace)){  ##do every personale
##re-calculate complexity when done with every previous personale to determine who's next...
##sort by complexity
resort.config.data <- data.frame(persondata, strucdata,
flexible_holidays = rep(Inf,nrow(contraspace)),
flexible_workdays = rep(Inf,nrow(contraspace)),
complexity = rep(Inf,nrow(contraspace)))
for(indexrow in 1:nrow(resort.config.data)){
availabledays <- contraspace.updated[indexrow,]
availabledays <- contraspace_days[availabledays == 0]
available.holidays <- availabledays[(availabledays %in% holidays)]
available.workdays <- availabledays[!(availabledays %in% holidays)]
#
resort.config.data$flexible_holidays[indexrow] <- length(available.holidays) - (strucdata$holidays[indexrow] - appoint_holidays[indexrow])
resort.config.data$flexible_workdays[indexrow] <- length(available.workdays) - (strucdata$workdays[indexrow] - appoint_workdays[indexrow])
resort.config.data$complexity[indexrow] <- min(c(resort.config.data$flexible_holidays[indexrow],
resort.config.data$flexible_workdays[indexrow]))
}#end for
if(length(p.index.done)!=0){
resort.config.data <- resort.config.data[-p.index.done,] ##select only the remaining personale
}#end if
##skip if there is complexity < 0
if(sum(resort.config.data$complexity < 0) != 0){
skip <- T
break #exit for loop
}#end if
##
resort.config.data <- resort.config.data[order(resort.config.data$complexity, decreasing = F),]
## identify the index of which personale to do next
if (irow != 1){
min_complexity <- resort.config.data$complexity[1]
min_names <- resort.config.data$name[resort.config.data$complexity %in% min_complexity]
next.p.index <- c(1:nrow(persondata))[persondata$name %in%  min_names]
if(length(next.p.index)>1){ next.p.index <- sample(next.p.index, 1) }
}else{
next.p.index <- sample(1:nrow(workspace), 1) ##start with a random personale
}#end if
p.index.done <- c(p.index.done, next.p.index)
#### plan personale according to next.p.index
availabledays <- contraspace.updated[next.p.index,]
availabledays <- contraspace_days[availabledays != 1]
##identify which workday/holiday had been appointed prior
holiday.appointed <- holidays[holidays %in% contraspace_days[appointspace[next.p.index,]==1]]
workdays <- contraspace_days[-holidays]
workday.appointed <- workdays[workdays %in% contraspace_days[appointspace[next.p.index,]==1]]
##reset
holiday.to.fill <- NULL
workday.to.fill <- NULL
##
if (strucdata$holidays[next.p.index]!=0){
available.holidays <- availabledays[(availabledays %in% holidays)]
if(((length(available.holidays)+length(holiday.appointed)) < strucdata$holidays[next.p.index]) |
(length(available.holidays)+length(holiday.appointed)) == 0){
skip <- T
break #exit for loop
}else{
holiday.to.fill <- c(holiday.appointed, available.holidays)
if(length(available.holidays)>1){ #only sample when there is more than one choice
holiday.to.fill <- c(holiday.appointed,
sample(available.holidays, strucdata$holidays[next.p.index] - appoint_struc$holidays[next.p.index]))
}#end if
}#end if
}#end if
if (strucdata$workdays[next.p.index]!=0){
available.workdays <- availabledays[!(availabledays %in% holidays)]
if(((length(available.workdays)+length(workday.appointed)) < strucdata$workdays[next.p.index]) |
(length(available.workdays)+length(workday.appointed)) == 0){
skip <- T
break #exit for loop
}else{
workday.to.fill <- c(workday.appointed, available.workdays)
if(length(available.workdays)>1){ #only sample when there is more than one choice
workday.to.fill <- c(workday.appointed,
sample(available.workdays, strucdata$workdays[next.p.index] - appoint_struc$workdays[next.p.index]))
}#end if
}#end if
}#end if
##
if (length(holiday.to.fill)!=0){
workspace[next.p.index, c(holiday.to.fill)] <- 1
}#end if
if (length(workday.to.fill)!=0){
workspace[next.p.index, c(workday.to.fill)] <- 1
}#end if
##update contraspace if 2 duties exist per day
contraspace.updated[,(apply(workspace,2,sum) == 2)] <- 1
##update contraspace according to strucdata status
contraspace.updated[apply(workspace[,c(holidays)],1,sum) == strucdata$holidays, c(holidays)] <- 1 ##if already match holiday struc for every person
contraspace.updated[apply(workspace[,-c(holidays)],1,sum) == strucdata$workdays, -c(holidays)] <- 1 ##if already match workday struc for every person
##
#
}#end for
#
workspace <- appointspace ##initialize with appointment space
contraspace.updated <- (contraspace | appointspace)*1
##update contraspace if 2 duties exist per day (do this first, because it can be filled by appointment)
contraspace.updated[,(apply(workspace,2,sum) == 2)] <- 1
##Planner algorithm
skip = F
##record which personale was done....
p.index.done <- c()
##
for(irow in 1:nrow(workspace)){  ##do every personale
##re-calculate complexity when done with every previous personale to determine who's next...
##sort by complexity
resort.config.data <- data.frame(persondata, strucdata,
flexible_holidays = rep(Inf,nrow(contraspace)),
flexible_workdays = rep(Inf,nrow(contraspace)),
complexity = rep(Inf,nrow(contraspace)))
for(indexrow in 1:nrow(resort.config.data)){
availabledays <- contraspace.updated[indexrow,]
availabledays <- contraspace_days[availabledays == 0]
available.holidays <- availabledays[(availabledays %in% holidays)]
available.workdays <- availabledays[!(availabledays %in% holidays)]
#
resort.config.data$flexible_holidays[indexrow] <- length(available.holidays) - (strucdata$holidays[indexrow] - appoint_holidays[indexrow])
resort.config.data$flexible_workdays[indexrow] <- length(available.workdays) - (strucdata$workdays[indexrow] - appoint_workdays[indexrow])
resort.config.data$complexity[indexrow] <- min(c(resort.config.data$flexible_holidays[indexrow],
resort.config.data$flexible_workdays[indexrow]))
}#end for
if(length(p.index.done)!=0){
resort.config.data <- resort.config.data[-p.index.done,] ##select only the remaining personale
}#end if
##skip if there is complexity < 0
if(sum(resort.config.data$complexity < 0) != 0){
skip <- T
break #exit for loop
}#end if
##
resort.config.data <- resort.config.data[order(resort.config.data$complexity, decreasing = F),]
## identify the index of which personale to do next
if (irow != 1){
min_complexity <- resort.config.data$complexity[1]
min_names <- resort.config.data$name[resort.config.data$complexity %in% min_complexity]
next.p.index <- c(1:nrow(persondata))[persondata$name %in%  min_names]
if(length(next.p.index)>1){ next.p.index <- sample(next.p.index, 1) }
}else{
next.p.index <- sample(1:nrow(workspace), 1) ##start with a random personale
}#end if
p.index.done <- c(p.index.done, next.p.index)
#### plan personale according to next.p.index
availabledays <- contraspace.updated[next.p.index,]
availabledays <- contraspace_days[availabledays != 1]
##identify which workday/holiday had been appointed prior
holiday.appointed <- holidays[holidays %in% contraspace_days[appointspace[next.p.index,]==1]]
workdays <- contraspace_days[-holidays]
workday.appointed <- workdays[workdays %in% contraspace_days[appointspace[next.p.index,]==1]]
##reset
holiday.to.fill <- NULL
workday.to.fill <- NULL
##
if (strucdata$holidays[next.p.index]!=0){
available.holidays <- availabledays[(availabledays %in% holidays)]
if(((length(available.holidays)+length(holiday.appointed)) < strucdata$holidays[next.p.index]) |
(length(available.holidays)+length(holiday.appointed)) == 0){
skip <- T
break #exit for loop
}else{
holiday.to.fill <- c(holiday.appointed, available.holidays)
if(length(available.holidays)>1){ #only sample when there is more than one choice
holiday.to.fill <- c(holiday.appointed,
sample(available.holidays, strucdata$holidays[next.p.index] - appoint_struc$holidays[next.p.index]))
}#end if
}#end if
}#end if
if (strucdata$workdays[next.p.index]!=0){
available.workdays <- availabledays[!(availabledays %in% holidays)]
if(((length(available.workdays)+length(workday.appointed)) < strucdata$workdays[next.p.index]) |
(length(available.workdays)+length(workday.appointed)) == 0){
skip <- T
break #exit for loop
}else{
workday.to.fill <- c(workday.appointed, available.workdays)
if(length(available.workdays)>1){ #only sample when there is more than one choice
workday.to.fill <- c(workday.appointed,
sample(available.workdays, strucdata$workdays[next.p.index] - appoint_struc$workdays[next.p.index]))
}#end if
}#end if
}#end if
##
if (length(holiday.to.fill)!=0){
workspace[next.p.index, c(holiday.to.fill)] <- 1
}#end if
if (length(workday.to.fill)!=0){
workspace[next.p.index, c(workday.to.fill)] <- 1
}#end if
##update contraspace if 2 duties exist per day
contraspace.updated[,(apply(workspace,2,sum) == 2)] <- 1
##update contraspace according to strucdata status
contraspace.updated[apply(workspace[,c(holidays)],1,sum) == strucdata$holidays, c(holidays)] <- 1 ##if already match holiday struc for every person
contraspace.updated[apply(workspace[,-c(holidays)],1,sum) == strucdata$workdays, -c(holidays)] <- 1 ##if already match workday struc for every person
##
#
}#end for
#
workspace <- appointspace ##initialize with appointment space
contraspace.updated <- (contraspace | appointspace)*1
##update contraspace if 2 duties exist per day (do this first, because it can be filled by appointment)
contraspace.updated[,(apply(workspace,2,sum) == 2)] <- 1
##Planner algorithm
skip = F
##record which personale was done....
p.index.done <- c()
##
for(irow in 1:nrow(workspace)){  ##do every personale
##re-calculate complexity when done with every previous personale to determine who's next...
##sort by complexity
resort.config.data <- data.frame(persondata, strucdata,
flexible_holidays = rep(Inf,nrow(contraspace)),
flexible_workdays = rep(Inf,nrow(contraspace)),
complexity = rep(Inf,nrow(contraspace)))
for(indexrow in 1:nrow(resort.config.data)){
availabledays <- contraspace.updated[indexrow,]
availabledays <- contraspace_days[availabledays == 0]
available.holidays <- availabledays[(availabledays %in% holidays)]
available.workdays <- availabledays[!(availabledays %in% holidays)]
#
resort.config.data$flexible_holidays[indexrow] <- length(available.holidays) - (strucdata$holidays[indexrow] - appoint_holidays[indexrow])
resort.config.data$flexible_workdays[indexrow] <- length(available.workdays) - (strucdata$workdays[indexrow] - appoint_workdays[indexrow])
resort.config.data$complexity[indexrow] <- min(c(resort.config.data$flexible_holidays[indexrow],
resort.config.data$flexible_workdays[indexrow]))
}#end for
if(length(p.index.done)!=0){
resort.config.data <- resort.config.data[-p.index.done,] ##select only the remaining personale
}#end if
##skip if there is complexity < 0
if(sum(resort.config.data$complexity < 0) != 0){
skip <- T
break #exit for loop
}#end if
##
resort.config.data <- resort.config.data[order(resort.config.data$complexity, decreasing = F),]
## identify the index of which personale to do next
if (irow != 1){
min_complexity <- resort.config.data$complexity[1]
min_names <- resort.config.data$name[resort.config.data$complexity %in% min_complexity]
next.p.index <- c(1:nrow(persondata))[persondata$name %in%  min_names]
if(length(next.p.index)>1){ next.p.index <- sample(next.p.index, 1) }
}else{
next.p.index <- sample(1:nrow(workspace), 1) ##start with a random personale
}#end if
p.index.done <- c(p.index.done, next.p.index)
#### plan personale according to next.p.index
availabledays <- contraspace.updated[next.p.index,]
availabledays <- contraspace_days[availabledays != 1]
##identify which workday/holiday had been appointed prior
holiday.appointed <- holidays[holidays %in% contraspace_days[appointspace[next.p.index,]==1]]
workdays <- contraspace_days[-holidays]
workday.appointed <- workdays[workdays %in% contraspace_days[appointspace[next.p.index,]==1]]
##reset
holiday.to.fill <- NULL
workday.to.fill <- NULL
##
if (strucdata$holidays[next.p.index]!=0){
available.holidays <- availabledays[(availabledays %in% holidays)]
if(((length(available.holidays)+length(holiday.appointed)) < strucdata$holidays[next.p.index]) |
(length(available.holidays)+length(holiday.appointed)) == 0){
skip <- T
break #exit for loop
}else{
holiday.to.fill <- c(holiday.appointed, available.holidays)
if(length(available.holidays)>1){ #only sample when there is more than one choice
holiday.to.fill <- c(holiday.appointed,
sample(available.holidays, strucdata$holidays[next.p.index] - appoint_struc$holidays[next.p.index]))
}#end if
}#end if
}#end if
if (strucdata$workdays[next.p.index]!=0){
available.workdays <- availabledays[!(availabledays %in% holidays)]
if(((length(available.workdays)+length(workday.appointed)) < strucdata$workdays[next.p.index]) |
(length(available.workdays)+length(workday.appointed)) == 0){
skip <- T
break #exit for loop
}else{
workday.to.fill <- c(workday.appointed, available.workdays)
if(length(available.workdays)>1){ #only sample when there is more than one choice
workday.to.fill <- c(workday.appointed,
sample(available.workdays, strucdata$workdays[next.p.index] - appoint_struc$workdays[next.p.index]))
}#end if
}#end if
}#end if
##
if (length(holiday.to.fill)!=0){
workspace[next.p.index, c(holiday.to.fill)] <- 1
}#end if
if (length(workday.to.fill)!=0){
workspace[next.p.index, c(workday.to.fill)] <- 1
}#end if
##update contraspace if 2 duties exist per day
contraspace.updated[,(apply(workspace,2,sum) == 2)] <- 1
##update contraspace according to strucdata status
contraspace.updated[apply(workspace[,c(holidays)],1,sum) == strucdata$holidays, c(holidays)] <- 1 ##if already match holiday struc for every person
contraspace.updated[apply(workspace[,-c(holidays)],1,sum) == strucdata$workdays, -c(holidays)] <- 1 ##if already match workday struc for every person
##
#
}#end for
#
sapply(1:nrow(workspace),
function(x){
mininterval(c(1:ncol(workspace))[c(workspace[x,]==1)])
})
View(resort.config.data)
holiday.appointed
workday.appointed
next.p.index
View(workspace)
