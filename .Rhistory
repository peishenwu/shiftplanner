workday.to.fill <- c(workday.appointed, available.workdays)
if(length(available.workdays)>1){ #only sample when there is more than one choice
workday.to.fill <- c(workday.appointed,
sample(available.workdays, strucdata$workdays[irow] - appoint_struc$workdays[irow]))
}#end if
}#end if
}#end if
##
if (length(holiday.to.fill)!=0){
workspace[irow, c(holiday.to.fill)] <- 1
}#end if
if (length(workday.to.fill)!=0){
workspace[irow, c(workday.to.fill)] <- 1
}#end if
##update contraspace if 2 duties exist per day
contraspace.updated[,(apply(workspace,2,sum) == 2)] <- 1
##update contraspace according to strucdata status
contraspace.updated[apply(workspace[,c(holidays)],1,sum) == strucdata$holidays, c(holidays)] <- 1 ##if already match holiday struc for every person
contraspace.updated[apply(workspace[,-c(holidays)],1,sum) == strucdata$workdays, -c(holidays)] <- 1 ##if already match workday struc for every person
##
#
}#end for
View(workspace)
apply(workspace,2,sum)
apply(workspace[,holidays],1,sum)
apply(workspace[,-holidays],1,sum)
strucdata$holidays
apply(workspace[,holidays],1,sum) == strucdata$holidays
apply(workspace[,-holidays],1,sum) == strucdata$workdays
View(strucdata)
options(stringsAsFactors = FALSE,
scipen=999) ##disable scientific number notation
set.seed(1234)
library(xlsx)
#library(utils)
library(compiler)
#
##do Iterations
iter_max = 30000
#
config.data <- read.xlsx("planner_config.xlsx", 1, row.names = NULL)
contraspace <- config.data[2:nrow(config.data),-c(1,2,ncol(config.data), (ncol(config.data)-1))]
persondata <- config.data[2:nrow(config.data),c(1,2)]
Encoding(persondata$name) <- "UTF-8"
strucdata <- config.data[2:nrow(config.data),c(ncol(config.data), (ncol(config.data)-1))]
holidays <- config.data[1,-c(1,2,ncol(config.data), (ncol(config.data)-1))]
holidays <- as.numeric(gsub("X","",names(holidays[,holidays == 1])))
contraspace_days <- as.numeric(gsub("X","",names(contraspace)))
junior_rowindex <- c(1:length(persondata$level))[persondata$level %in% c("R1","R2")]
senior_rowindex <- c(1:length(persondata$level))[persondata$level %in% c("R3","R4")]
##sort by complexity
sort.config.data <- data.frame(persondata, strucdata,
flexible_holidays = rep(Inf,nrow(contraspace)),
flexible_workdays = rep(Inf,nrow(contraspace)),
contraspace)
for(irow in 1:nrow(contraspace)){
availabledays <- contraspace[irow,]
availabledays <- contraspace_days[availabledays == 0]
available.holidays <- availabledays[(availabledays %in% holidays)]
available.workdays <- availabledays[!(availabledays %in% holidays)]
#
sort.config.data$flexible_holidays[irow] <- length(available.holidays) - strucdata$holidays[irow]
sort.config.data$flexible_workdays[irow] <- length(available.workdays) - strucdata$workdays[irow]
}#end for
sort.config.data <- sort.config.data[order(sort.config.data$flexible_holidays,
sort.config.data$flexible_workdays,
decreasing = F),]
contraspace <- sort.config.data[,-c(1:6)]
appointspace <- 1*(contraspace == 2)
contraspace <- contraspace - 2*appointspace
##
strucdata <- sort.config.data[, c(3,4)]
persondata <- sort.config.data[, c(1,2)]
## check for configuration error
if ((sum(sort.config.data$flexible_holidays < 0) + sum(sort.config.data$flexible_workdays < 0)) != 0){
stop("Error !! Someone set too much contras, leading to not enough available workdays or holidays")
}#end if
count_holidays <- length(holidays)
count_workdays <- length(contraspace_days) - count_holidays
if (sum(strucdata$workdays) != 2*count_workdays | sum(strucdata$holidays) != 2*count_holidays){
stop("Error in holidays or workdays configuration")
}#end if
## if more than two persons appoint the same day for on-duty, then it's an error
if (sum(apply(contraspace, 2, function(x){sum(x == 2)}) > 2) != 0){
stop("Error !! more than two persons appoint the same day for on-duty")
}#end if
appoint_holidays <- apply(appointspace[,holidays],1,sum)
appoint_workdays <- apply(appointspace[,-holidays],1,sum)
appoint_struc <- data.frame(workdays = appoint_workdays,
holidays = appoint_holidays)
#strucdata$holidays <- strucdata$holidays - appoint_holidays
#strucdata$workdays <- strucdata$workdays - appoint_workdays
##worker functions
getintervals <- function(x){
result = Inf
if (length(x) >1){
result = (sapply(2:length(x),function(i){x[i]-x[i-1]}))
}
result
}#end function
repeatdetect <- function(x, target){
result = 0
if (length(x)>1){
result <- sum(sapply(2:length(x),
function(i){
(x[i] == x[i-1]) * (x[i] == target)
}))
}
result
}#end function
#pb <- txtProgressBar(min = 1, max = iter_max, style=3)
#progress <- function(n){ setTxtProgressBar(pb, n) }
##
count_iter = 0
results <- list()
iter_log <- rep(0,iter_max %/% 250)
##worker functions
mininterval <- function(x){
result = Inf
if (length(x) >1){
#result = min(sapply(2:length(x),function(i){x[i]-x[i-1]}))
result = min(x[2:length(x)] - x[1:length(x)-1]) #vectorized version
}
result
}#end function
##
init_time = Sys.time() #set time at beginning
##
workspace <- appointspace ##initialize with appointment space
contraspace.updated <- (contraspace | appointspace)*1
##update contraspace if 2 duties exist per day (do this first, because it can be filled by appointment)
contraspace.updated[,(apply(workspace,2,sum) == 2)] <- 1
##Planner algorithm
skip = F
for(irow in 1:nrow(workspace)){
availabledays <- contraspace.updated[irow,]
availabledays <- contraspace_days[availabledays != 1]
##identify which workday/holiday had been appointed prior
holiday.appointed <- contraspace_days[appointspace[irow,]==1][holidays]
holiday.appointed <- holiday.appointed[complete.cases(holiday.appointed)]
workday.appointed <- contraspace_days[appointspace[irow,]==1][-holidays]
workday.appointed <- workday.appointed[complete.cases(workday.appointed)]
##reset
holiday.to.fill <- NULL
workday.to.fill <- NULL
##
if (strucdata$holidays[irow]!=0){
available.holidays <- availabledays[(availabledays %in% holidays)]
if((length(available.holidays) == 0) | (length(available.holidays) < strucdata$holidays[irow])){
skip <- T
break #exit for loop
}else{
holiday.to.fill <- c(holiday.appointed, available.holidays)
if(length(available.holidays)>1){ #only sample when there is more than one choice
holiday.to.fill <- c(holiday.appointed,
sample(available.holidays, strucdata$holidays[irow] - appoint_struc$holidays[irow]))
}#end if
}#end if
}#end if
if (strucdata$workdays[irow]!=0){
available.workdays <- availabledays[!(availabledays %in% holidays)]
if((length(available.workdays) == 0) | (length(available.workdays) < strucdata$workdays[irow])){
skip <- T
break #exit for loop
}else{
workday.to.fill <- c(workday.appointed, available.workdays)
if(length(available.workdays)>1){ #only sample when there is more than one choice
workday.to.fill <- c(workday.appointed,
sample(available.workdays, strucdata$workdays[irow] - appoint_struc$workdays[irow]))
}#end if
}#end if
}#end if
##
if (length(holiday.to.fill)!=0){
workspace[irow, c(holiday.to.fill)] <- 1
}#end if
if (length(workday.to.fill)!=0){
workspace[irow, c(workday.to.fill)] <- 1
}#end if
##update contraspace if 2 duties exist per day
contraspace.updated[,(apply(workspace,2,sum) == 2)] <- 1
##update contraspace according to strucdata status
contraspace.updated[apply(workspace[,c(holidays)],1,sum) == strucdata$holidays, c(holidays)] <- 1 ##if already match holiday struc for every person
contraspace.updated[apply(workspace[,-c(holidays)],1,sum) == strucdata$workdays, -c(holidays)] <- 1 ##if already match workday struc for every person
##
#
}#end for
#
workspace <- appointspace ##initialize with appointment space
contraspace.updated <- (contraspace | appointspace)*1
##update contraspace if 2 duties exist per day (do this first, because it can be filled by appointment)
contraspace.updated[,(apply(workspace,2,sum) == 2)] <- 1
##Planner algorithm
skip = F
for(irow in 1:nrow(workspace)){
availabledays <- contraspace.updated[irow,]
availabledays <- contraspace_days[availabledays != 1]
##identify which workday/holiday had been appointed prior
holiday.appointed <- contraspace_days[appointspace[irow,]==1][holidays]
holiday.appointed <- holiday.appointed[complete.cases(holiday.appointed)]
workday.appointed <- contraspace_days[appointspace[irow,]==1][-holidays]
workday.appointed <- workday.appointed[complete.cases(workday.appointed)]
##reset
holiday.to.fill <- NULL
workday.to.fill <- NULL
##
if (strucdata$holidays[irow]!=0){
available.holidays <- availabledays[(availabledays %in% holidays)]
if((length(available.holidays) == 0) | (length(available.holidays) < strucdata$holidays[irow])){
skip <- T
break #exit for loop
}else{
holiday.to.fill <- c(holiday.appointed, available.holidays)
if(length(available.holidays)>1){ #only sample when there is more than one choice
holiday.to.fill <- c(holiday.appointed,
sample(available.holidays, strucdata$holidays[irow] - appoint_struc$holidays[irow]))
}#end if
}#end if
}#end if
if (strucdata$workdays[irow]!=0){
available.workdays <- availabledays[!(availabledays %in% holidays)]
if((length(available.workdays) == 0) | (length(available.workdays) < strucdata$workdays[irow])){
skip <- T
break #exit for loop
}else{
workday.to.fill <- c(workday.appointed, available.workdays)
if(length(available.workdays)>1){ #only sample when there is more than one choice
workday.to.fill <- c(workday.appointed,
sample(available.workdays, strucdata$workdays[irow] - appoint_struc$workdays[irow]))
}#end if
}#end if
}#end if
##
if (length(holiday.to.fill)!=0){
workspace[irow, c(holiday.to.fill)] <- 1
}#end if
if (length(workday.to.fill)!=0){
workspace[irow, c(workday.to.fill)] <- 1
}#end if
##update contraspace if 2 duties exist per day
contraspace.updated[,(apply(workspace,2,sum) == 2)] <- 1
##update contraspace according to strucdata status
contraspace.updated[apply(workspace[,c(holidays)],1,sum) == strucdata$holidays, c(holidays)] <- 1 ##if already match holiday struc for every person
contraspace.updated[apply(workspace[,-c(holidays)],1,sum) == strucdata$workdays, -c(holidays)] <- 1 ##if already match workday struc for every person
##
#
}#end for
#
workspace <- appointspace ##initialize with appointment space
contraspace.updated <- (contraspace | appointspace)*1
##update contraspace if 2 duties exist per day (do this first, because it can be filled by appointment)
contraspace.updated[,(apply(workspace,2,sum) == 2)] <- 1
##Planner algorithm
skip = F
for(irow in 1:nrow(workspace)){
availabledays <- contraspace.updated[irow,]
availabledays <- contraspace_days[availabledays != 1]
##identify which workday/holiday had been appointed prior
holiday.appointed <- contraspace_days[appointspace[irow,]==1][holidays]
holiday.appointed <- holiday.appointed[complete.cases(holiday.appointed)]
workday.appointed <- contraspace_days[appointspace[irow,]==1][-holidays]
workday.appointed <- workday.appointed[complete.cases(workday.appointed)]
##reset
holiday.to.fill <- NULL
workday.to.fill <- NULL
##
if (strucdata$holidays[irow]!=0){
available.holidays <- availabledays[(availabledays %in% holidays)]
if((length(available.holidays) == 0) | (length(available.holidays) < strucdata$holidays[irow])){
skip <- T
break #exit for loop
}else{
holiday.to.fill <- c(holiday.appointed, available.holidays)
if(length(available.holidays)>1){ #only sample when there is more than one choice
holiday.to.fill <- c(holiday.appointed,
sample(available.holidays, strucdata$holidays[irow] - appoint_struc$holidays[irow]))
}#end if
}#end if
}#end if
if (strucdata$workdays[irow]!=0){
available.workdays <- availabledays[!(availabledays %in% holidays)]
if((length(available.workdays) == 0) | (length(available.workdays) < strucdata$workdays[irow])){
skip <- T
break #exit for loop
}else{
workday.to.fill <- c(workday.appointed, available.workdays)
if(length(available.workdays)>1){ #only sample when there is more than one choice
workday.to.fill <- c(workday.appointed,
sample(available.workdays, strucdata$workdays[irow] - appoint_struc$workdays[irow]))
}#end if
}#end if
}#end if
##
if (length(holiday.to.fill)!=0){
workspace[irow, c(holiday.to.fill)] <- 1
}#end if
if (length(workday.to.fill)!=0){
workspace[irow, c(workday.to.fill)] <- 1
}#end if
##update contraspace if 2 duties exist per day
contraspace.updated[,(apply(workspace,2,sum) == 2)] <- 1
##update contraspace according to strucdata status
contraspace.updated[apply(workspace[,c(holidays)],1,sum) == strucdata$holidays, c(holidays)] <- 1 ##if already match holiday struc for every person
contraspace.updated[apply(workspace[,-c(holidays)],1,sum) == strucdata$workdays, -c(holidays)] <- 1 ##if already match workday struc for every person
##
#
}#end for
#
View(workspace)
apply(workspace[,-holidays],1,sum) == strucdata$workdays
apply(workspace[,holidays],1,sum) == strucdata$holidays
apply(workspace,2,sum)
options(stringsAsFactors = FALSE,
scipen=999)
library(utils)
library(doSNOW)
message("initalizing parallel threads...")
cl <- makeSOCKcluster(20)
registerDoSNOW(cl)
##
data <- readRDS("planner_output.rds")
results <- data$results
contraspace <- data$contraspace[,-c(1,2)] #remove names, levels columns
holidays <- data$holidays
contraspace_days <- data$contraspace_days
persondata <- data$contraspace[, c(1,2)]
strucdata <- data$strucdata
appointspace <- data$appointspace
junior_rowindex <- c(1:length(persondata$level))[persondata$level %in% c("R1","R2")]
senior_rowindex <- c(1:length(persondata$level))[persondata$level %in% c("R3","R4")]
##worker functions
mininterval <- function(x){
result = Inf
if (length(x) >1){
#result = min(sapply(2:length(x),function(i){x[i]-x[i-1]}))
result = min(x[2:length(x)] - x[1:length(x)-1]) #vectorized version
}
result
}#end function
getintervals <- function(x){
result = Inf
if (length(x) >1){
result = (sapply(2:length(x),function(i){x[i]-x[i-1]}))
}
result
}#end function
repeatdetect <- function(x, target){
result = 0
if (length(x)>1){
result <- sum(sapply(2:length(x),
function(i){
(x[i] == x[i-1]) * (x[i] == target)
}))
}
result
}#end function
#
swap.Agg <- c()
for(ritem in 1:length(results)){
message(paste("\nWorking on result ",ritem,"/",length(results),sep=""))
##Prepare swap space
swapspace <- data.frame(p.index = NA, day = NA, HorW = NA)
for(p.index in 1:nrow(results[[ritem]])){
dutydays <- contraspace_days[results[[ritem]][p.index,-c(1,2)] == 1]
dutyholidays <- dutydays[dutydays %in% holidays]
dutyworkdays <- dutydays[!(dutydays %in% holidays)]
#
swapspace <- rbind(swapspace,
data.frame(p.index = rep(p.index, length(dutyholidays)),
day = dutyholidays,
HorW = rep(1, length(dutyholidays))),
data.frame(p.index = rep(p.index, length(dutyworkdays)),
day = dutyworkdays,
HorW = rep(2, length(dutyworkdays))))
}#end for
swapspace <- swapspace[complete.cases(swapspace),]
##1 for Holiday, 2 for Workday
for(HW.index in 1:2){
#message(paste("Working on ",c("holidays","workdays")[HW.index],sep=""))
swapwork <- swapspace[swapspace$HorW == HW.index,]
swapcomb <- combn(1:nrow(swapwork),2)
#
pb <- txtProgressBar(min = 1, max = ncol(swapcomb), style=3)
progress <- function(n){ setTxtProgressBar(pb, n) }
opts <- list(progress=progress)
#parallel approach for faster performance...
swap.result  <- foreach(comb.index = 1:ncol(swapcomb), .options.snow=opts) %dopar% {
foreach.result = NA
#skip if the days or person are the same
if((swapwork$day[swapcomb[1,comb.index]] != swapwork$day[swapcomb[2,comb.index]])
&(swapwork$p.index[swapcomb[1,comb.index]] != swapwork$p.index[swapcomb[2,comb.index]])){
#check if swap contra exists
if((contraspace[swapwork$p.index[swapcomb[1,comb.index]],swapwork$day[swapcomb[2,comb.index]]]!=1)
&(contraspace[swapwork$p.index[swapcomb[2,comb.index]],swapwork$day[swapcomb[1,comb.index]]]!=1)){
#swap if not skipped
workspace <- results[[ritem]][,-c(1,2)]
workspace[swapwork$p.index[swapcomb[1,comb.index]],swapwork$day[swapcomb[2,comb.index]]] <- 1
workspace[swapwork$p.index[swapcomb[2,comb.index]],swapwork$day[swapcomb[1,comb.index]]] <- 1
workspace[swapwork$p.index[swapcomb[1,comb.index]],swapwork$day[swapcomb[1,comb.index]]] <- 0
workspace[swapwork$p.index[swapcomb[2,comb.index]],swapwork$day[swapcomb[2,comb.index]]] <- 0
#check for any errors such as QDs
min.int <- sapply(1:nrow(workspace),
function(x){
mininterval(c(1:ncol(workspace))[c(workspace[x,]==1)])
})
if (sum(min.int>1) == nrow(workspace)){
#if no errors then save swapped result
foreach.result <- workspace
}#end if
}#end if
}#end if
foreach.result
}#end foreach combination
##remove NAs
rswap.result <- c()
for (rswap.index in 1:length(swap.result)){
if(identical(swap.result[[rswap.index]], NA)){next}
rswap.result <- c(rswap.result, list(swap.result[[rswap.index]]))
}#end for if NAs
##
swap.Agg <- c(swap.Agg, rswap.result)
}#end for HW.index
}#end for every results
##calculate qualities of post-swapped results and pre-swapped results
##remove names and level columns
r.results <- c()
for(r.index in 1:length(results)){
r.results <- c(r.results, list(results[[r.index]][,-c(1,2)]))
}
results <- c(r.results,swap.Agg)
##calculate quality metrics
## 1. counts of QODs
## 2. discreteness of shifts
## 3. number of days where "senior residents on duty = 2 personale"
## 4. number of continuous QODs
quality <- data.frame(resultIndex = 1:length(results),
cQODs = rep(NA,length(results)),
discrete = rep(NA,length(results)),
cSenior = rep(NA,length(results)),
continQODs = rep(NA,length(results)),
NoContras = rep(NA, length(results)),
NotFollowHoliday = rep(NA, length(results)),
NotFollowWorkday = rep(NA, length(results)),
OnlyTwoDutiesPerDay = rep(NA, length(results)),
FollowAllAppointments = rep(NA, length(results)))
pb <- txtProgressBar(min = 1, max = length(results), style=3)
message("\nCalculating quality...")
for (item in 1:length(results)){
progress(item)
#
quality$cSenior[item] <- sum(apply(results[[item]][senior_rowindex,],2,sum) == 2)
quality$discrete[item] <- min(apply(results[[item]],1,
function(x){
mean(getintervals(c(1:ncol(results[[item]]))[x == 1]))
}))
quality$cQODs[item] <- sum(apply(results[[item]],1,
function(x){
sum(getintervals(c(1:ncol(results[[item]]))[x == 1]) == 2)
}))
quality$continQODs[item] <- sum(apply(results[[item]],1,
function(x){
repeatdetect(getintervals(c(1:ncol(results[[item]]))[x == 1]),2)
}))
quality$NoContras[item] <- (sum((contraspace + results[[item]]) == 2) == 0)
quality$NotFollowHoliday[item] <- sum(apply(results[[item]][,c(holidays)],1,sum) != strucdata$holidays)
quality$NotFollowWorkday[item] <- sum(apply(results[[item]][,-c(holidays)],1,sum) != strucdata$workdays)
quality$OnlyTwoDutiesPerDay[item] <- sum(apply(results[[item]],2,sum) != 2)
quality$FollowAllAppointments[item] <- sum((results[[item]] & appointspace) != appointspace) == 0
}#end for
View(sort.config.data)
View(quality)
quality[quality$NoContras == T &
quality$NotFollowHoliday == 0 &
quality$NotFollowWorkday == 0 &
quality$OnlyTwoDutiesPerDay == 0 &
quality$continQODs == 0 &
quality$cSenior == 0 &
quality$FollowAllAppointments == T,]
quality$NoContras == T
quality$NotFollowHoliday == 0
quality$NotFollowWorkday == 0
quality$NotFollowHoliday == 0 &
quality$NotFollowWorkday == 0
quality$OnlyTwoDutiesPerDay == 0
quality$continQODs == 0
quality$cSenior == 0
quality$FollowAllAppointments == T
quality <- quality[order(quality$cQODs,
quality$cSenior,
-quality$discrete,
decreasing = F),]
quality <- quality[quality$NoContras == T &
quality$NotFollowHoliday == 0 &
quality$NotFollowWorkday == 0 &
quality$OnlyTwoDutiesPerDay == 0 &
quality$continQODs == 0 &
#  quality$cSenior == 0 &
quality$FollowAllAppointments == T,]
View(quality)
nrow(quality)
quality <- quality[quality$NoContras == T &
quality$NotFollowHoliday == 0 &
quality$NotFollowWorkday == 0 &
quality$OnlyTwoDutiesPerDay == 0 &
quality$continQODs == 0 &
quality$cSenior == 0 &
quality$FollowAllAppointments == T,]
quality <- quality[order(quality$cQODs,
quality$cSenior,
-quality$discrete,
decreasing = F),]
nrow(quality)
